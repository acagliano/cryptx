
/*
 *--------------------------------------
 * Program Name: DEMO
 * Author: Anthony Cagliano
 * License: GPL3
 * Description: ASN.1 Decoder Demo
 *--------------------------------------
 *
 * This program demonstrates how to extract public key information from
 * a DER-encoded RSA key format. The DER-formatted public key exported by
 * pycryptodomex's RSA module looks like this:
 
 
 SEQUENCE {
 RSAMetadata ::= SEQUENCE {
 pkcs#1IdString		OBJECT IDENTIFIER
 nullObject			NULL
 }
 RSAData ::= BIT STRING {
 RSAPublicKey ::= SEQUENCE {
 modulus           INTEGER,  -- n
 publicExponent    INTEGER   -- e
 }
 }
 }
 
 *
 */

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <encodex.h>
#define CEMU_CONSOLE ((char*)0xFB0000)

uint8_t asn1_demo[] = {0x30,0x81,0x9f,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x81,0x8d,0x00,0x30,0x81,0x89,0x02,0x81,0x81,0x00,0xc0,0x3c,0xa0,0x1c,0x0b,0x0e,0xbe,0xb0,0x64,0x62,0xfc,0x2e,0x0e,0x8d,0x04,0x9d,0xc1,0xa7,0xc7,0xce,0x88,0x8d,0x85,0x87,0x6a,0x41,0x93,0x45,0x25,0x23,0x25,0x38,0x74,0xce,0x4f,0xf1,0x46,0xf5,0x3b,0x94,0x19,0xb2,0x1d,0x6d,0xfc,0xa0,0x46,0x04,0x64,0xc6,0xb2,0x33,0x77,0x2f,0xb9,0x89,0x33,0x6a,0xce,0x84,0x8a,0x5a,0xff,0x88,0x1f,0x03,0x38,0x31,0x1d,0xe6,0x08,0xdd,0xd0,0xae,0x86,0xfd,0xf5,0xd9,0x25,0x4f,0x82,0x1c,0x93,0xa4,0xcc,0x32,0x22,0x67,0xa2,0x16,0x68,0xb9,0xd6,0xae,0xe4,0xb2,0xee,0x80,0x93,0xb1,0x4a,0x2b,0x80,0x27,0x27,0xfd,0x99,0x18,0x90,0xb6,0xe2,0x97,0x2a,0x14,0x51,0x02,0xca,0x73,0x36,0x41,0x52,0x18,0xdc,0xa8,0xe8,0x69,0x44,0x09,0x02,0x03,0x01,0x00,0x01,};
// use the 'test.py' file in this example's root folder to generate more key structs for testing

int main(void)
{
	struct cryptx_asn1_context asn1_state;
	asn1_error_t err;
	uint8_t *ptr;
	size_t elem_len;
	uint8_t tag;
	uint8_t flags;
	
	sprintf(CEMU_CONSOLE, "\n\n----------------------------------\nENCODEX ASN.1 Decoder Demo\n");
	
	err = cryptx_asn1_start(&asn1_state, asn1_demo, sizeof asn1_demo);
	sprintf(CEMU_CONSOLE, "\nASN.1 parser init complete. Exit code %u.\n",  err);
	if(err != ASN1_OK) return 1;
	
	while(err != ASN1_EOF){
		err = cryptx_asn1_decode(&asn1_state, &ptr, &elem_len, &tag, &flags);
		if(err)
			sprintf(CEMU_CONSOLE, "Decoder error %u\n", err);
		else
			sprintf(CEMU_CONSOLE, "Object Data, Tag Id: %u, Flags: %u, Size: %u, Addr: %p\n", tag, flags, elem_len, ptr);
		if(!CRYPTX_ASN1_ISCONSTRUCTED(flags)){
			err = cryptx_asn1_next(&asn1_state);
		}
	}
	
	
	return 0;
}


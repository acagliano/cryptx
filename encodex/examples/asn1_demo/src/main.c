/*
 *--------------------------------------
 * Program Name: DEMO
 * Author: Anthony Cagliano
 * License: GPL3
 * Description: ASN.1 Decoder Demo
 *--------------------------------------
 *
 * This program demonstrates how to extract public key information from
 * a DER-encoded RSA key format. The DER-formatted public key exported by
 * pycryptodomex's RSA module looks like this:
 
 
	SEQUENCE {
		RSAMetadata ::= SEQUENCE {
			pkcs#1IdString		OBJECT IDENTIFIER
			nullObject			NULL
		}
		RSAData ::= BIT STRING {
			RSAPublicKey ::= SEQUENCE {
				modulus           INTEGER,  -- n
				publicExponent    INTEGER   -- e
			}
		}
	}
 
 *
 */

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <encodex.h>
#define CEMU_CONSOLE ((char*)0xFB0000)

uint8_t asn1_demo[] = {0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc3, 0x2d, 0x78, 0x78, 0xfa, 0xf8, 0xee, 0x16, 0xd5, 0x79, 0x28, 0x67, 0x2b, 0x74, 0xf6, 0xd7, 0x5d, 0x42, 0x28, 0x92, 0x42, 0x5c, 0x63, 0x4e, 0x40, 0x9e, 0x9f, 0x40, 0x0b, 0x36, 0xd8, 0x9e, 0x88, 0xe8, 0xda, 0x81, 0xbb, 0x02, 0x4f, 0x79, 0x36, 0xab, 0xe7, 0x20, 0x61, 0x03, 0x33, 0x13, 0x2b, 0x86, 0x5e, 0x6a, 0x18, 0x7c, 0x22, 0xd5, 0x55, 0x9f, 0xe4, 0x82, 0x43, 0xee, 0x67, 0xa9, 0x16, 0x33, 0x9f, 0xc1, 0x4b, 0x99, 0xb1, 0x8a, 0xef, 0x61, 0x1d, 0x90, 0x7e, 0xcf, 0x5c, 0x23, 0x1c, 0xa7, 0xe4, 0xea, 0x3a, 0x51, 0x17, 0x73, 0xf0, 0x97, 0x1b, 0x4a, 0x90, 0x4a, 0x2a, 0x4a, 0x24, 0x0d, 0xa3, 0x18, 0x3c, 0xed, 0x78, 0xfa, 0x3c, 0xec, 0x72, 0xef, 0x7c, 0xa6, 0x35, 0x0f, 0xaf, 0x88, 0x91, 0x0a, 0x93, 0x4b, 0xb6, 0xd1, 0x53, 0x43, 0x28, 0xdb, 0x14, 0x69, 0xb4, 0x74, 0x0f, 0xbc, 0x87, 0xdd, 0x8a, 0x6b, 0x05, 0xa8, 0x1b, 0x15, 0x52, 0xb8, 0xe7, 0x77, 0x4e, 0x82, 0x36, 0xc8, 0x10, 0x08, 0xdf, 0x78, 0xe4, 0xd8, 0x00, 0xb1, 0x32, 0x23, 0xf2, 0xbf, 0x8d, 0xad, 0x86, 0x96, 0xa0, 0x30, 0x41, 0x42, 0x44, 0x69, 0xde, 0x8b, 0x0c, 0x9d, 0x24, 0x31, 0x68, 0x61, 0x53, 0x83, 0xfb, 0x35, 0x2d, 0xc8, 0xec, 0x0a, 0x14, 0x29, 0x6f, 0x29, 0x25, 0x08, 0xe1, 0xcd, 0xba, 0xc5, 0x3e, 0xc4, 0x81, 0xa1, 0xbc, 0x52, 0x5e, 0xc6, 0xf1, 0xa3, 0xaa, 0xb9, 0xfc, 0xa3, 0xc4, 0x0c, 0x31, 0xd5, 0x37, 0x01, 0xf3, 0x4f, 0x2f, 0x5d, 0xcf, 0xb5, 0x50, 0xf3, 0xa8, 0xdd, 0x09, 0x85, 0xdf, 0x99, 0x2f, 0x90, 0x12, 0x8b, 0xbc, 0x6f, 0x16, 0x1f, 0x9f, 0x85, 0xc5, 0x22, 0x5e, 0x65, 0xa0, 0x4a, 0x26, 0x9f, 0xff, 0xce, 0xb8, 0x02, 0xc7, 0x3f, 0xfa, 0xad, 0x1f, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01};


int main(void)
{
	asn1_obj_t output[10] = {0};
	asn1_obj_t output2[10] = {0};
	sprintf(CEMU_CONSOLE, "\n\n----------------------------------\nENCODEX ASN.1 Decoder Demo\n");

	// parse ASN.1 encoded data
	/*
	 This call to asn1_decode will return 3 objects.
	 1. pkcs#1IdString
	 2. nullObject
	 3. RSAData
	 This is because any tag with the constructed bit set will be automatically
	 deconstructed further, but the BIT STRING object does not have this tag set.
	 You will need to then call asn1_decode on this object specifically to break it down further.
	 */
	size_t obj_ct = asn1_decode(asn1_demo, sizeof asn1_demo, output, 10);
	sprintf(CEMU_CONSOLE, "Decode complete, %u objects parsed.\n", obj_ct);
	for(int i=0; i<obj_ct; i++)
		sprintf(CEMU_CONSOLE, "Obj %u, Tag Id: %u, Size: %u, Addr: %u\n", i, output[i].tag, output[i].len, output[i].data);
	
	
	/*
	 For reasons unknown, DER encodes the integer modulus and public exponent as a BIT STRING
	 with a single byte of 0x00 padding, followed by a SEQUENCE containing the modulus and
	 exponent.
	 Also the modulus itself is usually prepended with a single 0x00 byte as well.
	 This call to asn1_decode will return 2 objects.
	 1. modulus
	 2. exponent
	 */
	obj_ct = asn1_decode(output[2].data, output[2].len, output2, 10);
	for(int i=0; i<obj_ct; i++)
		sprintf(CEMU_CONSOLE, "Obj %u, Tag Id: %u, Size: %u, Addr: %u\n", i, output2[i].tag, output2[i].len, output2[i].data);
	
	
	// Strip the first byte of modulus and you have the information you need for
	// rsa_encrypt().
    return 0;
}

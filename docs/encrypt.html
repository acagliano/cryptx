<!DOCTYPE html>
<html>
	<head>
		<title>CryptX Documentation</title>
		<link type="text/css" rel="stylesheet" href="style.css" />
		<link rel="stylesheet" href="scripts/highlight/styles/default.min.css">
			<script src="scripts/highlight/highlight.min.js"></script>
		<style>
			.code {display:inline-block; padding:5px;}
			tr {margin:0 5%; padding:0;}
			.lib-ref tr>td:nth-of-type(2) {
				color:black; font-weight:normal;
			}
		</style>
	</head>
	<body>
		<div id="sidebar">
			<div id="title"><a href="index.html">
				CryptX
				<span style="font-size:50%;">12</span>
			</a></div><br />
			<div class="major-header">INTRODUCTION</div>
				<div class="navitem"><a href="index.html">What is CryptX?</a></div>
				<div class="navitem"><a href="installing.html">Installing the Libraries</a></div>
			<div class="major-header">COMPONENTS &amp; API</div>
				<div class="navitem"><a href="hashlib.html">HASHLIB</a></div>
				<div class="navitem active">ENCRYPT</div>
				<div class="navitem"><a href="encodex.html">ENCODEX</a></div>
			<div class="major-header">MORE INFO</div>
			<div class="navitem"><a href="cryptanalysis.html">Cryptanalysis</a></div>
			<div class="navitem"><a href="credits.html">Credits</a></div>
			<div class="navitem"><a href="legal.html">Legal</a></div>
			
		</div>
		<div id="content"><div>
			<p><span style="font-weight:bold;">ENCRYPT</span>, as its name suggests, provides multiple encryption algorithms for the calculator.</p>
			<div class="major-header">Authors</div>
			<ul>
				<li>Anthony Cagliano</li>
				<li>Adam Beckingham</li>
				<li>jacobly (modular exponentiation)</li>
				<li>Zeroko (information on sourcing randomness)</li>
			</ul>
			<div class="major-header">API Documentation</div>
			<p>I will be doing the documentation here a bit differently. Rather than a catalog of functions with text-walls of information that would make even Chuck Norris hide under a table, I will present at the start of each module a short flavor text about the implementation and then some commented-code illustrating its usage. After that, a brief overview of response codes and functions for that module will be provided.</p>
			<div class="alert">
				This red tooltip style indicates security-critical information. It indicates implementation details that, if ignored, may result in your application leaking information. If you have any questions or do not understand something please do not ignore the tooltip; contact me for clarification.
			</div><br />
			<div class="section">
				<div class="minor-header">Cryptographically-Secure Random Number Generator (CS-RNG)</div>
				<div class="section side-ruled">
					<p>The <span class="emphasis">rand</span> implemenation provided by the CE C toolchain provides statistical randomness but not unpredictability and is therefore not suitable for use as a cryptographic RNG. If you require randomness for cryptographic purposes, please use this generator instead.</p>
					<pre class="code"><code class="language-c">
						// initialize the RNG
						if(!cryptx_csrand_init(SAMPLING_THOROUGH)) return;
						// you can use SAMPLING_FAST for less entropy but faster completion
						// remember to catch a return value of False from this function and respond properly
						
						// generate a uint32_t
						uint32_t rvar = cryptx_csrand_get();
						
						// fill a buffer
						uint8_t tbuf[16];
						cryptx_csrand_fill(tbuf, sizeof(tbuf));</code></pre>
					<dl>
						
						<dt class="lib-ref">bool cryptx_csrand_init(cryptx_csrng_sampling_mode mode);</dt>
						<dd>Initializes the secure random number generator.<br />
							<span class="param">mode</span>: SAMPLING_THOROUGH | SAMPLING_FAST.<br />
							<span class="param">returns</span>: [bool] True if SRNG init succeeded. False if failed.
						</dd><br />
						<dt class="lib-ref">uint32_t cryptx_csrand_get(void);</dt>
						<dd>Generates a secure 32-bit random integer.<br />
							<span class="param">returns</span>: [uint32_t] A securely-random 32-bit integer.
						</dd><br />
						<dt class="lib-ref">bool cryptx_csrand_fill(void *buffer, size_t size);</dt>
						<dd>Fills a buffer with securely random bytes.<br />
							<span class="param">buffer</span>: Pointer to buffer to fill.<br />
							<span class="param">size</span>: Length of buffer.<br />
							<span class="param">returns</span>: [bool] True if operation succeeded. False if failed.
						</dd>
					</dl>
				</div>
				<br />
				<div class="minor-header">Advanced Encryption Standard (AES)</div>
				<div class="section side-ruled">
					<p>AES is currently regarded as the gold standard for symmetric encryption. It is the primary encryption algorithm used in a secure session, after a (usually slower) key negotiation has succeeded. See RSA and ECDH for key negotiation. If you need the best possible security with this library, use AES-GCM cipher mode OR use one of the other two cipher modes with an HMAC appended to the message.</p>
					
					<p>
					<span style="font-weight:bold;">Supported Cipher Modes:</span><br />
					Cyclic Block Chain (CBC) mode<br />
					Counter (CTR) mode<br />
					Galois-Counter (GCM) mode<br />
					<span style="font-style:italic;">see the header file for details on how to set cipher mode.<br />If you don&apos;t know what you&apos;re doing, just use AES-GCM and use the examples below for reference.</span>
					</p>
					<pre class="code"><code class="language-c">
						<span style="font-weight:bold;">As Sender:</span>
						// this code assumes that the buffer `key` is some secret
						// that has been already negotiated (see RSA/ECDH)
						
						// declare the context and error code
						<span class="lib-ref">struct cryptx_aes_ctx</span> context;
						<span class="lib-ref">aes_error_t</span> err;
						
						// a random IV
						uint8_t aes_iv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						<span class="lib-ref">cryptx_csrand_fill(aes_iv, CRYPTX_AES_IV_SIZE)</span>;
						
						// initialize the context
						err = <span class="lib-ref">cryptx_aes_init(&context, key, sizeof(key), aes_iv, sizeof(aes_iv), CRYPTX_AES_GCM_FLAGS)</span>;
						if(err) return;		// if error code, don't proceed.
						
						// now assume a packet to encrypt and send:
						// buffer name `packet` with arbitrary specs
						#define HEADER_LOC 0
						#define HEADER_LEN 8
						#define PLAINTEXT_LEN 128
						uint8_t packet[HEADER_LEN + PLAINTEXT_LEN + <span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						
						// queue header for authentication
						err = <span class="lib-ref">cryptx_aes_update_aad(&context, &packet[HEADER_LOC], HEADER_LEN)</span>;
						if(err) return;
						
						// now encrypt plaintext. Note that in-place encryption is valid.
						err = <span class="lib-ref">cryptx_aes_encrypt(&context, &packet[HEADER_LEN], PLAINTEXT_LEN, &packet[HEADER_LEN])</span>;
						
						// now render auth tag to end of packet
						err = <span class="lib-ref">cryptx_aes_digest(&context, &packet[HEADER_LEN + CIPHERTEXT_LEN])</span>;
						
						// then send your packet using whatever network framework you set up
						// stream should begin with the IV used for encryption
						network_send(aes_iv, sizeof(aes_iv));
						network_send(packet, sizeof(packet));</code></pre><br />
					<pre class="code"><code class="language-c">
						<span style="font-weight:bold;">As Receiver:</span>
						// this code assumes that the buffer `key` is some secret
						// that has been already negotiated (see RSA/ECDH)
						
						// declare the context and error code
						<span class="lib-ref">struct cryptx_aes_ctx</span> context;
						<span class="lib-ref">aes_error_t</span> err;
						
						// you have received the packet, mirroring the format
						// demonstrated above.
						// arbitrarily name received packet buffer `recv`.
						// this means we have the following:
						#define HEADER_LOC 0
						#define HEADER_LEN 8
						#define PLAINTEXT_LEN 128
						uint8_t *aes_iv = &recv[0];
						uint8_t *header = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						uint8_t *ciphertext = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span> + HEADER_LEN];
						uint8_t *tag = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span> + HEADER_LEN + PLAINTEXT_LEN];
						
						// initialize the context
						err = <span class="lib-ref">cryptx_aes_init(&context, key, sizeof(key), aes_iv, CRYPTX_AES_IV_SIZE, CRYPTX_AES_GCM_FLAGS)</span>;
						if(err) return;		// if error code, don't proceed.
						
						// verify the tag first. If auth check fails, refuse decryption
						if(!<span class="lib-ref">cryptx_aes_verify(&context, header, HEADER_LEN, ciphertext, PLAINTEXT_LEN, tag)</span>)
						return;
						
						// now decrypt plaintext. Note that in-place decryption is valid.
						err = <span class="lib-ref">cryptx_aes_decrypt(&context, &packet[HEADER_LEN], PLAINTEXT_LEN, &packet[HEADER_LEN])</span>;</code></pre>
					
					<dl>
						<dt class="lib-ref">AES API Overview<hr />
							&emsp;Response Codes
							<table width="100%" style="margin-left:5%; font-size:12px;">
								<col width="40%" />
								<col width="60%" />
								<tr><td>AES_OK</td><td>No error occurred</td></tr>
								<tr><td>AES_INVALID_ARG</td><td>One or more arguments invalid</td></tr>
								<tr><td>AES_INVALID_MSG</td><td>Plaintext invalid</td></tr>
								<tr><td>AES_INVALID_CIPHERMODE</td><td>Cipher mode out of range</td></tr>
								<tr><td>AES_INVALID_PADDINGMODE</td><td>Padding mode out of range</td></tr>
								<tr><td>AES_INVALID_CIPHERTEXT</td><td>Ciphertext invalid, bad length<br />GCM tag mismatch.</td></tr>
								<tr><td>AES_INVALID_OPERATION</td><td>Encrypt called on decrypt context, v.v.<br />GCM context used after digest render.</td></tr>
							</table>
						</dt>
						<dd></dd><br />
						
						<dt class="lib-ref">aes_error_t cryptx_aes_init(<br />
							&emsp;&emsp;&emsp;&emsp;struct cryptx_aes_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;const void *key, size_t keylen,<br />
							&emsp;&emsp;&emsp;&emsp;const void *iv, size_t ivlen,<br />
							&emsp;&emsp;&emsp;&emsp;uint24_t flags);</dt>
						<dd>Initializes an AES context for encryption or decryption.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">key</span>: Pointer to AES key.<br />
							<span class="param">keylen</span>: Length of the key, in bytes.<br />
							<span class="param">iv</span>: Pointer to initialization vector.<br />
							<span class="param">ivlen</span>: Length of the initialization vector, in bytes.<br />
							<span class="param">flags</span>: A series of cipher configuration options, bitwise ORd together. See header for details.<br />
							<span class="param">returns</span>: [aes_error_t] Status of cipher initialization.
						</dd><br />
						<dt class="lib-ref">aes_error_t cryptx_aes_encrypt(<br />
							&emsp;&emsp;&emsp;&emsp;struct cryptx_aes_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;void *plaintext, size_t len,<br />
							&emsp;&emsp;&emsp;&emsp;void *ciphertext);</dt>
						<dd>Encrypts a message using the AES state.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">plaintext</span>: Pointer to data to encrypt.<br />
							<span class="param">len</span>: Length of the plaintext, in bytes.<br />
							<span class="param">ciphertext</span>: Buffer to write encrypted data to. In-place encryption supported.<br />
							<span class="param">returns</span>: [aes_error_t] Status of encrypt operation.
						</dd><br />
						<dt class="lib-ref">aes_error_t cryptx_aes_decrypt(<br />
							&emsp;&emsp;&emsp;&emsp;struct cryptx_aes_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;void *ciphertext, size_t len,<br />
							&emsp;&emsp;&emsp;&emsp;void *plaintext);</dt>
						<dd>Decrypts a message using the AES state.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">ciphertext</span>: Pointer to data to decrypt.<br />
							<span class="param">len</span>: Length of the ciphertext, in bytes.<br />
							<span class="param">plaintext</span>: Buffer to write decrypted data to. In-place decryption supported.<br />
							<span class="param">returns</span>: [aes_error_t] Status of decrypt operation.
						</dd><br />
						<dt class="lib-ref">aes_error_t cryptx_aes_update_aad(<br />
							&emsp;&emsp;&emsp;&emsp;struct cryptx_aes_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;const void *aad, size_t aad_len);</dt>
						<dd>GCM mode only. Updates the digest state for additional authenticated data.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">aad</span>: Pointer to additional authenticated data.<br />
							<span class="param">aad_len</span>: Length of the AAD, in bytes.<br />
							<span class="param">returns</span>: [aes_error_t] Status of AAD update operation.
						</dd><br />
						<dt class="lib-ref">aes_error_t cryptx_aes_digest(struct cryptx_aes_ctx *context, uint8_t *digest);</dt>
						<dd>GCM mode only. Returns the authentication tag for the current context state.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">digest</span>: Pointer to buffer to write authentication tag.<br />
							<span class="param">returns</span>: [aes_error_t] Status of digest output operation.
						</dd><br />
						<dt class="lib-ref">bool cryptx_aes_verify(<br />
							&emsp;&emsp;&emsp;&emsp;const struct cryptx_aes_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;const void *aad, size_t aad_len,<br />
							&emsp;&emsp;&emsp;&emsp;const void *ciphertext, size_t ciphertext_len,<br />
							&emsp;&emsp;&emsp;&emsp;uint8_t *tag);</dt>
						<dd>GCM mode only. Returns the authentication tag for the current context state.<br />
							<span class="param">context</span>: Pointer to AES context.<br />
							<span class="param">aad</span>: Pointer to additional authenticated data.<br />
							<span class="param">aad_len</span>: Length of the AAD, in bytes.<br />
							<span class="param">ciphertext</span>: Pointer to ciphertext data.<br />
							<span class="param">len</span>: Length of the ciphertext, in bytes.<br />
							<span class="param">tag</span>: Pointer to expected tag included with encrypted message.<br />
							<span class="param">returns</span>: [bool] True if expected tag matches locally-computed tag. False if mis-match.
						</dd><br />
					</dl>
					<div class="alert">
						<span style="font-weight:bold; text-decoration:underline;">Key Cycling Requirements</span><br />
						It is recommended that you cycle your encryption key after you have encrypted between 2<sup>32</sup> and 2<sup>64</sup> blocks of data (depending on cipher mode). You will never realistically reach this.
					</div>
					<div class="alert">
						<span style="font-weight:bold; text-decoration:underline;">IV Uniqueness Requirement for AES-GCM</span><br />
						In GCM cipher mode, it is crucial that each message stream have a unique initialization vector. Failure to ensure this may cause the cipher to leak information.
					</div>
					
				</div>
				
				<br />
				<a name="rsa"></a>
				<div class="minor-header">Rivest-Shamir-Adleman (RSA)</div>
				<div class="section side-ruled">
					<p>RSA is form of public key encryption. It is one of the algorithms (usually) used to share a secret for a symmetric encryption system like AES. It is slow and in recent years has been getting easier to defeat for smaller key lengths. NIST recommends a minimum key length of 2048 bits (higher is preferred but not feasible on the target hardware) which provides 112 bits of security (<span class="citation"><a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">citation</a> - see Section 5.6.1.1, Table 2</span>). The RSA implementation here automatically pre-encodes the message with Optimal Asymmetric Encryption Padding (OAEP) v2.2 prior to encryption. This implementation is also encryption-only, as generating a private key would prove to be a very time-consuming operation on the TI-84+ CE.</p>
					<pre class="code"><code class="language-c">
						// The RSA implementation here is encrypt-only. The overhead for keygen
						// is too expensive on this platform.
						// We assume that a remote host has generated a public/private RSA keypair
						// and shared the public with with you, and we have written that key to
						// the buffer `rsa_key`.
						
						// declare RSA cipher error code
						<span class="lib-ref">rsa_error_t</span> err;
						
						// generate an AES secret. remember RSA is used for secret negotiation,
						// not sustained encryption
						uint8_t aes_key[32];
						<span class="lib-ref">cryptx_csrand_fill(aes_key, sizeof(aes_key))</span>;
						
						// now encrypt the AES secret
						uint8_t ciphertext[sizeof(rsa_key)];
						err = <span class="lib-ref">cryptx_rsa_encrypt(aes_key, sizeof(aes_key), rsa_key, sizeof(rsa_key), ciphertext, SHA256)</span>;
						if(err) return;
						
						network_send(ciphertext, sizeof(ciphertext));</code></pre>
					<dl>
						
						<dt class="lib-ref">RSA API Overview<hr />
							&emsp;Response Codes
							<table width="100%" style="margin-left:5%; font-size:12px;">
								<col width="40%" />
								<col width="60%" />
								<tr><td>RSA_OK</td><td>No error occurred</td></tr>
								<tr><td>RSA_INVALID_ARG</td><td>One or more arguments invalid</td></tr>
								<tr><td>RSA_INVALID_MSG</td><td>Plaintext invalid</td></tr>
								<tr><td>RSA_INVALID_MODULUS</td><td>Key invalid; usually not odd</td></tr>
								<tr><td>RSA_ENCODING_ERROR</td><td>OAEP encoder error; usually message length issues.</td></tr>
							</table>
						</dt>
						<dd></dd><br />
						
						<dt class="lib-ref">rsa_error_t cryptx_rsa_encrypt(<br />
						&emsp;&emsp;&emsp;&emsp;const void* msg, size_t msglen,<br />
						&emsp;&emsp;&emsp;&emsp;const void* pubkey, size_t keylen,<br />
						&emsp;&emsp;&emsp;&emsp;void* ciphertext, uint8_t oaep_hash_alg);</dt>
						<dd>Encodes a message using OAEPv2.2 and then performs RSA encryption.<br />
						<span class="param">msg</span>: Pointer to plaintext to encrypt/encode.<br />
						<span class="param">msglen</span>: Length of the message, in bytes.<br />
						<span class="param">pubkey</span>: Pointer to the RSA public modulus (public exponent hardcoded to 65537).<br />
						<span class="param">keylen</span>: Length of the RSA public modulus, in bytes.<br />
						<span class="param">ciphertext</span>: Pointer to buffer to write encrypted message. In-place encryption NOT supported.<br />
						<span class="param">oaep_hash_algorithm</span>: The hash algorithm to use for OAEP encoding.<br />
						<span class="param">returns</span>: [rsa_error_t] Status of encode/encrypt operation.
					</dd>
						</dl>
				</div>
				<br />
				<a name="ecdh"></a>
				<div class="minor-header">Elliptic Curve Diffie-Hellman (ECDH)</div>
				<div class="section side-ruled">
					<p>ECDH is form of public key negotiation. It is another algorithm (usually) used to share a secret for a symmetric encryption system like AES. Due to the mathematical complexity and behavior of elliptic curves over a finite field, cryptographic algorithms based on them tend to be more secure than their non-EC counterparts. The NIST-defined curve implemented in this library, SECT233k1, has an effective security level approximately equal to that of 2048-bit RSA (<span class="citation"><a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">citation</a> - see Section 5.6.1.1, Table 2</span>).</p>
					<pre class="code"><code class="language-c">
						// declare ECDH context consisting of public and private key
						<span class="lib-ref">struct cryptx_ecdh_context</span> context;
						// declare error handler
						<span class="lib-ref">ecdh_error_t</span> err;
						
						// initialize context
						// this fills the private key with random bytes, then
						// generates a public key = private key * base point G
						err = <span class="lib-ref">cryptx_ecdh_init(&context)</span>;
						if(err) return;
						
						// assume that other party has shared its own private key with you
						// and that key is saved in buffer named `recv`.
						// secret is computes as secret = remote_public * your_private
						uint8_t secret[<span class="lib-ref">CRYPTX_ECDH_PRIVKEY_SIZE</span>];
						err = <span class="lib-ref">cryptx_ecdh_secret(&context, recv, secret)</span>;
						if (err) return;
						
						// note that `secret` should not be used as is. Pass it through a
						// cryptographic hash or a KDF, and use the output of that as
						// your symmetric key.</code></pre>
					
					<dl>
						
						<dt class="lib-ref">ECDH API Overview<hr />
							&emsp;Response Codes
							<table width="100%" style="margin-left:5%; font-size:12px;">
								<col width="40%" />
								<col width="60%" />
								<tr><td>ECDH_OK</td><td>No error occurred</td></tr>
								<tr><td>ECDH_INVALID_ARG</td><td>One or more arguments invalid</td></tr>
								<tr><td>ECDH_PRIVKEY_INVALID</td><td>Legacy, no longer returned</td></tr>
								<tr><td>ECDH_RPUBKEY_INVALID</td><td>Remote public key == point at infinity or not on curve</td></tr>
							</table>
						</dt>
						<dd></dd><br />
						
						
						<dt class="lib-ref">ecdh_error_t cryptx_ecdh_init(const struct cryptx_ecdh_ctx *context);</dt>
						<dd>Generates a random 233-bit scalar and computes elliptic curve public key.<br />
							Uses NIST-defined SECT233k1 elliptic curve, cofactor variant.<br />
							<span class="param">context</span>: Pointer to ECDH context.<br />
							<span class="param">returns</span>: [ecdh_error_t] Status of ECDH initialization.
						</dd><br />
						<dt class="lib-ref">ecdh_error_t cryptx_ecdh_secret(<br />
							&emsp;&emsp;&emsp;&emsp;const struct cryptx_ecdh_ctx *context,<br />
							&emsp;&emsp;&emsp;&emsp;const uint8_t *rpubkey, uint8_t *secret);</dt>
						<dd>Computes the product of the remote public key and your private key over the elliptic curve.<br />
							Uses NIST-defined SECT233k1 elliptic curve, cofactor variant.<br />
							<span class="param">context</span>: Pointer to ECDH context containing private key.<br />
							<span class="param">rpubkey</span>: Pointer to other party&apos;s public key.<br />
							<span class="param">secret</span>: Buffer to write output secret.<br />
							<span class="param">returns</span>: [ecdh_error_t] Status of ECDH initialization.
						</dd>
					</dl>
					<div class="alert">
						It is recommended that you do not use the output of cryptx_ecdh_secret() directly as your symmetric encryption secret. Instead, pass the output to a cryptographic hash such as SHA256 or to a key derivation function (KDF) such as the one provided in the HASHLIB library. Use the output of that as your encryption secret instead.
					</div>
				</div>
			</div>
				
			<a name="ae"></a>
			<div class="major-header">Addendum: Authenticated Encryption</div>
			<p>As great as encryption is, it is not the end of the problem. <span style="color:darkred; font-weight:bold;">Encryption alone only prevents someone reading the data, it does not protect against modification or forgery</span>. That task is performed by cryptographic hashes, HMACs, and authenticating cipher modes. The combination of a secure encryption algorithm with a secure authentication algorithm creates a construct known as <span style="font-weight:bold">authenticated encryption</span>. Almost all practical applications of data security today require authenticated encryption, so just get into the habit of doing it even if you think your application doesn&apos;t require it. CryptX provides two main methods of authenticated encryption.</p>
			<p>The first method is use a standard encryption-only cipher mode such as AES-CBC or AES-CTR and then to generate a cryptographic hash or HMAC for authentication. The hash or HMAC will then be embedded into the output message, usually at the end, to allow the recipient to validate the message. If you are using this method, there are a few constraints you must follow:</p>
			<ul class="alert">
				<span style="font-weight:bold; text-decoration:underline;">Standard Cipher Mode + HMAC</span>
				<li>Initialization vector/nonce blocks for encryption are securely pseudo-random.</li>
				<li>Encryption and HMAC keys are also securely pseudo-random and are long enough to be considered secure. Minimum key sizes recommended are 16 bytes.</li>
				<li>You are not using your encryption key as your HMAC key or vice versa. There are attack vectors that result from using the same key for encryption and authentication.</li>
				<li>Hash the entire message, even unencrypted portions.</li>
				<li>Generally hash the encrypted message, not the plaintext.</li>
			</ul>
			The second is method is to use the AES-GCM cipher mode. This is an authenticating cipher mode that uses AES-CTR mode for encryption and also maintains a hash field as you pass unencrypted data or ciphertext data to it. AES-GCM is generally secure as long as you follow these constraints:</p>
			<ul class="alert">
				<span style="font-weight:bold; text-decoration:underline;">AES Galois Counter Mode</span>
				<li>Initialization vector/nonce blocks for encryption are securely pseudo-random.</li>
				<li>Do not reuse the same initialization vector for another message stream. Once you render a digest for a data stream, you should generate a new initialization vector. Failure to do so can result in the cipher leaking information about the key used for encryption.</li>
			</ul>
			
			<span style="font-weight:bold;">Example of authenticated encryption, CryptX. by Anthony Cagliano</span>
			<pre class="code"><code class="language-c">
#include &lt;hashlib.h&gt;
#include &lt;encrypt.h&gt;

// this assumes that the AES secret ‘aes_key‘ and the HMAC secret ‘hmac_key‘
// have been negotiated beforehand.

// let’s send a simple ascii string
char* msg = "The daring fox jumped over the moon."

// the header is a size word, containing size of string plus our IV
// header can really be whatever you want, but some arbitrary nonsense as an example
size_t header = sizeof(msg)+AES_IVSIZE;

// allocate the memory we need
cryptx_aes_ctx ctx;
cryptx_hmac_ctx hmac;
uint8_t iv[AES_IVSIZE];

// doing this first allows us to
hmac_init(&hmac, hmac_key, sizeof hmac_key, SHA256);

// allocate a digest of the size we need
uint8_t hmac_digest[hmac.digest_len];

// !!!! NEVER PROCEED IF csrand_init() FAILS !!!
if(!cryptx_csrand_init()) return false;
cryptx_csrand_fill(iv, AES_IVSIZE);

// initialize AES context with mode , key , and iv
cryptx_aes_init(&ctx, aes_key, sizeof aes_key, iv, CRYPTX_AES_CTR_FLAGS(8, 8));

// encrypt message
// aes_encrypt supports in-place encryption
cryptx_aes_encrypt(&ctx, msg, strlen(msg), msg);

// hash everything you are sending, except the hash itself
cryptx_hmac_update(&hmac, &header, sizeof header);
cryptx_hmac_update(&hmac, iv, sizeof iv);
cryptx_hmac_update(&hmac, msg, strlen(msg));
cryptx_hmac_final(&hmac, hmac_digest);

// ps_queue/send are psuedo functions implying queueing data to send
// and then sending it
ps_queue(&header, sizeof header);
ps_queue(iv, sizeof iv);
ps_queue(msg, sizeof msg);
ps_queue(hmac_digest, sizeof hmac_digest);
ps_send();
			</code></pre>
			<hr />
			<iframe src="scripts/rtd-msg.html" style="width:100%; height:50px; border:none;"></iframe>
			<br />
		</div></div>
	</body>
	<script>hljs.highlightAll();</script>
</html>

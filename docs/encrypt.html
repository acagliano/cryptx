<!DOCTYPE html>
<html>
	<head>
		<title>CryptX Documentation</title>
		<link type="text/css" rel="stylesheet" href="style.css" />
		<link rel="stylesheet" href="scripts/highlight/styles/default.min.css">
			<script src="scripts/highlight/highlight.min.js"></script>
		<style>
			.code {display:inline-block; padding:5px;}
		</style>
	</head>
	<body>
		<div id="sidebar">
			<div id="title"><a href="index.html">
				CryptX
				<span style="font-size:50%;">11</span>
			</a></div><br />
			<div class="major-header">INTRODUCTION</div>
				<div class="navitem"><a href="index.html">What is CryptX?</a></div>
				<div class="navitem"><a href="installing.html">Installing the Libraries</a></div>
			<div class="major-header">COMPONENTS &amp; API</div>
				<div class="navitem"><a href="hashlib.html">HASHLIB</a></div>
				<div class="navitem active">ENCRYPT</div>
				<div class="navitem"><a href="encodex.html">ENCODEX</a></div>
			<div class="major-header">MORE INFO</div>
			<div class="navitem"><a href="cryptanalysis.html">Cryptanalysis</a></div>
			<div class="navitem"><a href="credits.html">Credits</a></div>
			<div class="navitem"><a href="legal.html">Legal</a></div>
			
		</div>
		<div id="content"><div>
			<p><span style="font-weight:bold;">ENCRYPT</span>, as its name suggests, provides multiple encryption algorithms for the calculator.</p>
			<div class="major-header">Authors</div>
			<ul>
				<li>Anthony Cagliano</li>
				<li>Adam Beckingham</li>
				<li>jacobly (modular exponentiation)</li>
				<li>Zeroko (information on sourcing randomness)</li>
			</ul>
			<div class="major-header">API Documentation</div>
			<p>I will be doing the documentation here a bit differently. Rather than a catalog of functions with text-walls of information that would make even Chuck Norris hide under a table, I will present at the start of each module a short flavor text about the implementation and then some commented-code illustrating its usage. To locate library modules, look for functions or macros prefixed with <span style="font-family:monospace; background:silver;">cryptx_</span> or <span style="font-family:monospace; background:silver;">CRYPTX_</span> and cross reference them with the header files for more information.</p>
			<div class="section">
				<div class="minor-header">Cryptographically-Secure Random Number Generator (CS-RNG)</div>
				<div class="section side-ruled">
					<p>The <span class="emphasis">rand</span> implemenation provided by the CE C toolchain provides statistical randomness but not unpredictability and is therefore not suitable for use as a cryptographic RNG. If you require randomness for cryptographic purposes, please use this generator instead.</p>
					<pre class="code"><code class="language-c">
						// initialize the RNG
						if(!<span class="lib-ref">cryptx_csrand_init(SAMPLING_THOROUGH)</span>) return;
						// you can use SAMPLING_FAST for less entropy but faster completion
						
						// generate a uint32_t
						uint32_t rvar = <span class="lib-ref">cryptx_csrand_get()</span>;
						
						// fill a buffer
						uint8_t tbuf[16];
						<span class="lib-ref">cryptx_csrand_fill(tbuf, sizeof(tbuf)</span>);</code></pre>
				</div>
				<br />
				<div class="minor-header">Advanced Encryption Standard (AES)</div>
				<div class="section side-ruled">
					<p>AES is currently regarded as the gold standard for symmetric encryption. It is the primary encryption mode in a secure session, after a (usually slower) key negotiation has succeeded. See RSA and ECDH for key negotiation. If you need the best possible security with this library, use AES-GCM cipher mode OR use one of the other two cipher modes with an HMAC appended to the message.</p>
					
					<p>
					<span style="font-weight:bold;">Supported Cipher Modes:</span><br />
					Cyclic Block Chain (CBC) mode<br />
					Counter (CTR) mode<br />
					Galois-Counter (GCM) mode<br />
					<span style="font-style:italic;">see the header file for details on how to set cipher mode.<br />If you don&apos;t know what you&apos;re doing, just use AES-GCM and use the examples below for reference.</span>
					</p>
					<pre class="code"><code class="language-c">
						<span style="font-weight:bold;">As Sender:</span>
						// this code assumes that the buffer `key` is some secret
						// that has been already negotiated (see RSA/ECDH)
						
						// declare the context and error code
						<span class="lib-ref">struct cryptx_aes_ctx</span> context;
						<span class="lib-ref">aes_error_t</span> err;
						
						// a random IV
						uint8_t aes_iv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						<span class="lib-ref">cryptx_csrand_fill(aes_iv, CRYPTX_AES_IV_SIZE)</span>;
						
						// initialize the context
						err = <span class="lib-ref">cryptx_aes_init(&context, key, sizeof(key), aes_iv, sizeof(aes_iv), CRYPTX_AES_GCM_FLAGS)</span>;
						if(err) return;		// if error code, don't proceed.
						
						// now assume a packet to encrypt and send:
						// buffer name `packet` with arbitrary specs
						#define HEADER_LOC 0
						#define HEADER_LEN 8
						#define PLAINTEXT_LEN 128
						uint8_t packet[HEADER_LEN + PLAINTEXT_LEN + <span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						
						// queue header for authentication
						err = <span class="lib-ref">cryptx_aes_update_aad(&context, &packet[HEADER_LOC], HEADER_LEN)</span>;
						if(err) return;
						
						// now encrypt plaintext. Note that in-place encryption is valid.
						err = <span class="lib-ref">cryptx_aes_encrypt(&context, &packet[HEADER_LEN], PLAINTEXT_LEN, &packet[HEADER_LEN])</span>;
						
						// now render auth tag to end of packet
						err = <span class="lib-ref">cryptx_aes_digest(&context, &packet[HEADER_LEN + CIPHERTEXT_LEN])</span>;
						
						// then send your packet using whatever network framework you set up
						// stream should begin with the IV used for encryption
						network_send(aes_iv, sizeof(aes_iv));
						network_send(packet, sizeof(packet));</code></pre><br />
					<pre class="code"><code class="language-c">
						<span style="font-weight:bold;">As Receiver:</span>
						// this code assumes that the buffer `key` is some secret
						// that has been already negotiated (see RSA/ECDH)
						
						// declare the context and error code
						<span class="lib-ref">struct cryptx_aes_ctx</span> context;
						<span class="lib-ref">aes_error_t</span> err;
						
						// you have received the packet, mirroring the format
						// demonstrated above.
						// arbitrarily name received packet buffer `recv`.
						// this means we have the following:
						#define HEADER_LOC 0
						#define HEADER_LEN 8
						#define PLAINTEXT_LEN 128
						uint8_t *aes_iv = &recv[0];
						uint8_t *header = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span>];
						uint8_t *ciphertext = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span> + HEADER_LEN];
						uint8_t *tag = &recv[<span class="lib-ref">CRYPTX_AES_IV_SIZE</span> + HEADER_LEN + PLAINTEXT_LEN];
						
						// initialize the context
						err = <span class="lib-ref">cryptx_aes_init(&context, key, sizeof(key), aes_iv, CRYPTX_AES_IV_SIZE, CRYPTX_AES_GCM_FLAGS)</span>;
						if(err) return;		// if error code, don't proceed.
						
						// verify the tag first. If auth check fails, refuse decryption
						if(!<span class="lib-ref">cryptx_aes_verify(&context, header, HEADER_LEN, ciphertext, PLAINTEXT_LEN, tag)</span>)
						return;
						
						// now decrypt plaintext. Note that in-place decryption is valid.
						err = <span class="lib-ref">cryptx_aes_decrypt(&context, &packet[HEADER_LEN], PLAINTEXT_LEN, &packet[HEADER_LEN])</span>;</code></pre>
					
				</div>
				
				<br />
				<a name="rsa"></a>
				<div class="minor-header">Rivest-Shamir-Adleman (RSA)</div>
				<div class="section side-ruled">
					<p>RSA is form of public key encryption. RSA is one of the algorithms (usually) used to share a secret for a symmetric encryption system like AES. It is slow and in recent years has been getting easier to defeat. NIST recommends a minimum key length of 2048 bits (higher is preferred but not feasible on the target hardware) which provides 112 bits of security (<span class="citation"><a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">citation</a> - see Section 5.6.1.1, Table 2</span>).</p>
					<pre class="code"><code class="language-c">
						/*
						The RSA implementation here is encrypt-only. The overhead for private keygen
						is far too expensive on this platform.
						*/
						// We assume that a remote host has generated a public/private RSA keypair
						// and shared the public with with you, and we have written that key to
						// the buffer `rsa_key`.
						
						// declare RSA cipher error code
						<span class="lib-ref">rsa_error_t</span> err;
						
						// generate an AES secret. remember RSA is used for secret negotiation,
						// not sustained encryption
						uint8_t aes_key[32];
						<span class="lib-ref">cryptx_csrand_fill(aes_key, sizeof(aes_key))</span>;
						
						// now encrypt the AES secret
						uint8_t ciphertext[sizeof(rsa_key)];
						err = <span class="lib-ref">cryptx_rsa_encrypt(aes_key, sizeof(aes_key), rsa_key, sizeof(rsa_key), ciphertext, SHA256)</span>;
						if(err) return;
						
						network_send(ciphertext, sizeof(ciphertext));</code></pre>
				</div>
				<br />
				<a name="ecdh"></a>
				<div class="minor-header">Elliptic Curve Diffie-Hellman (ECDH)</div>
				<div class="section side-ruled">
					<p>ECDH is form of public key negotiation. It is another algorithm (usually) used to share a secret for a symmetric encryption system like AES. Due to the greater complexity of key generation and the behavior of an elliptic curve over a finite field, elliptic curve keys tend to be more secure. The NIST-defined curve implemented in this library, SECT233k1, has an effective security level approximately equal to that of 2048-bit RSA (<span class="citation"><a target="_blank" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">citation</a> - see Section 5.6.1.1, Table 2</span>).</p>
					<pre class="code"><code class="language-c">
						// declare ECDH context consisting of public and private key
						<span class="lib-ref">struct cryptx_ecdh_context</span> context;
						// declare error handler
						<span class="lib-ref">ecdh_error_t</span> err;
						
						// initialize context
						// this fills the private key with random bytes, then
						// generates a public key = private key * base point G
						err = <span class="lib-ref">cryptx_ecdh_init(&context)</span>;
						if(err) return;
						
						// assume that other party has shared its own private key with you
						// and that key is saved in buffer named `recv`.
						// secret is computes as secret = remote_public * your_private
						uint8_t secret[<span class="lib-ref">CRYPTX_ECDH_PRIVKEY_SIZE</span>];
						err = <span class="lib-ref">cryptx_ecdh_secret(&context, recv, secret)</span>;
						if (err) return;
						
						// note that `secret` should not be used as is. Pass it through a
						// cryptographic hash or a KDF, and use the output of that as
						// your symmetric key.</code></pre>
				</div>
			</div>
				
			
			<div class="major-header">Addendum: Authenticated Encryption</div>
			<p>Authenticated encryption is an encryption scheme that produces a ciphertext that is not only obfuscated but also has its integrity and authenticity verifiable. This can be accomplished in a few ways, the most common of which are: (1) appending a signature, hash, or keyed hash to a message, and (2) implementing a cipher mode that integrates authentication.</p>
			<p>#2 above is not implemented in CryptX. Most of the authenticating cipher modes are computationally-intensive without hardware acceleration and may not be feasible for use on the TI-84+ CE. While consid- eration is being given to potentially adding a cipher mode such as OCB or GCM if a sufficiently-optimized implementation for this platform can be found (or devised), it is possible to construct a ciphertext guarded against tampering by using method #1, which this library does provide for.</p>
			<p>It is recommended that whenever you are sending data you need to be truly secure with this library, you always embed a keyed hash into the message that the recipient can validate. This functionality is provided by the HMAC implementation shown earlier in this document. Proper application of HMAC for ciphertext integrity requires the following considerations:</p>
			<ul>
				<li>Initialization vector/nonce blocks for encryption are securely pseudo-random.</li>
				<li>Encryption and HMAC keys are also securely pseudo-random and are long enough to be considered secure. Minimum key sizes recommended are 16 bytes.</li>
				<li>You are not using your encryption key as your HMAC key or vice versa. There are attack vectors that result from using the same key for encryption and authentication.</li>
				<li>Append a keyed hash (HMAC) of the initialization vector/nonce, encrypted message, and any other associated data such as packet headers to the outgoing message. On the receiving side, validate the HMAC before decryption and reject any message that does not authenticate. The HMAC key can be an application secret known to both parties or a generated nonce shared alongside the AES encryption key using RSA or another public key encryption method.</li>
			</ul>
			<span style="font-weight:bold;">Example of authenticated encryption, CryptX. by Anthony Cagliano</span>
			<pre class="code"><code class="language-c">
#include &lt;hashlib.h&gt;
#include &lt;encrypt.h&gt;

// this assumes that the AES secret ‘aes_key‘ and the HMAC secret ‘hmac_key‘
// have been negotiated beforehand.

// let’s send a simple ascii string
char* msg = "The daring fox jumped over the moon."

// the header is a size word, containing size of string plus our IV
// header can really be whatever you want, but some arbitrary nonsense as an example
size_t header = sizeof(msg)+AES_IVSIZE;

// allocate the memory we need
cryptx_aes_ctx ctx;
cryptx_hmac_ctx hmac;
uint8_t iv[AES_IVSIZE];

// doing this first allows us to
hmac_init(&hmac, hmac_key, sizeof hmac_key, SHA256);

// allocate a digest of the size we need
uint8_t hmac_digest[hmac.digest_len];

// !!!! NEVER PROCEED IF csrand_init() FAILS !!!
if(!cryptx_csrand_init()) return false;
cryptx_csrand_fill(iv, AES_IVSIZE);

// initialize AES context with mode , key , and iv
cryptx_aes_init(&ctx, aes_key, sizeof aes_key, iv, CRYPTX_AES_CTR_FLAGS(8, 8));

// encrypt message
// aes_encrypt supports in-place encryption
cryptx_aes_encrypt(&ctx, msg, strlen(msg), msg);

// hash everything you are sending, except the hash itself
cryptx_hmac_update(&hmac, &header, sizeof header);
cryptx_hmac_update(&hmac, iv, sizeof iv);
cryptx_hmac_update(&hmac, msg, strlen(msg));
cryptx_hmac_final(&hmac, hmac_digest);

// ps_queue/send are psuedo functions implying queueing data to send
// and then sending it
ps_queue(&header, sizeof header);
ps_queue(iv, sizeof iv);
ps_queue(msg, sizeof msg);
ps_queue(hmac_digest, sizeof hmac_digest);
ps_send();
			</code></pre>
			<hr />
			<iframe src="scripts/rtd-msg.html" style="width:100%; height:50px; border:none;"></iframe>
			<br />
		</div></div>
	</body>
	<script>hljs.highlightAll();</script>
</html>

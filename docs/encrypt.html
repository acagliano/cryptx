<!DOCTYPE html>
<html>
	<head>
		<title>CryptX Documentation</title>
		<link type="text/css" rel="stylesheet" href="style.css" />
		<link rel="stylesheet" href="scripts/highlight/styles/default.min.css">
			<script src="scripts/highlight/highlight.min.js"></script>
		<style>
			.code {display:inline-block; padding:5px;}
		</style>
	</head>
	<body>
		<div id="sidebar">
			<div id="title"><a href="index.html">
				CryptX
				<span style="font-size:50%;">10.0</span>
			</a></div><br />
			<div class="major-header">INTRODUCTION</div>
				<div class="navitem"><a href="index.html">What is CryptX?</a></div>
				<div class="navitem"><a href="installing.html">Installing the Libraries</a></div>
			<div class="major-header">COMPONENTS &amp; API</div>
				<div class="navitem"><a href="hashlib.html">HASHLIB</a></div>
				<div class="navitem active">ENCRYPT</div>
				<div class="navitem"><a href="encodex.html">ENCODEX</a></div>
			<div class="major-header">MORE INFO</div>
			<div class="navitem"><a href="cryptanalysis.html">Cryptanalysis</a></div>
			<div class="navitem"><a href="credits.html">Credits</a></div>
			<div class="navitem"><a href="legal.html">Legal</a></div>
			
		</div>
		<div id="content"><div>
			<p><span style="font-weight:bold;">ENCRYPT</span>, as its name suggests, provides multiple encryption algorithms for the calculator.</p>
			<div class="major-header">Authors</div>
			<ul>
				<li>Anthony Cagliano</li>
				<li>Adam Beckingham</li>
				<li>jacobly (modular exponentiation)</li>
				<li>Zeroko (information on sourcing randomness)</li>
			</ul>
			<div class="major-header">Definitions</div>
			<dl>
				<dt>SRNG (Secure Random Number Generator)</dt>
				<dd>A random number generator that provides (1) statistical randomness, (2) unpredictability, (3) resistance to state compromise.</dd><br />
				<dt>Encryption</dt>
				<dd>A reversible transformation of data designed to render it difficult for an unauthorized party to read. Another word for this is a <span style="font-weight:bold;">cipher</span>.</dd><br />
				<dt>Symmetric Encryption</dt>
				<dd>An encryption system in which a single key works for both encryption and decryption.</dd><br />
				<dt>Asymmetric Encryption</dt>
				<dd>An encryption system in which one key is used for encryption and a seperate key is used for decryption and there is some mathematical relationship between the two keys that allows them to reverse each other.</dd><br />
				<dt>Advanced Encryption Standard (AES)</dt>
				<dd>A symmetric encryption system defined by (1) 128, 192, or 256 bit keys (16, 24, 32 bytes), (2) a 128-bit (16 byte) block size, (3) 10-, 12-, and 14-round variants (depending on key size), and (4) a 128-bit (16 byte) randomized <span style="font-style:italic;">initialization vector</span>. AES, when properly implemented, remains unbroken.<br />
					<span style="font-weight:bold">Round</span> means number of times the algorithm performs transformations on the data. For example, AES-128 has 10 rounds of encryption. This means the transformation is repeated ten (10) times.
				</dd><br />
				<dt>RSA</dt>
				<dd>An asymmetric encryption system defined by two keys: one that is sent in the clear (public key) consisting of a public exponent and public modulus, and one that is kept secret (private key) consisting of a private exponent and private modulus. The public key is used to encrypt messages, the private is used to decrypt. The two are modular inverses of each other, such that:<br />
					<span class="code">
						encrypted = message <sup>public exponent</sup> % public modulus<br />
						message = encrypted <sup>private exponent</sup> % private modulus
					</span><br />
					Common key lengths are between 1024 and 2048 bits (128 bytes and 256 bytes), though 1024-bit RSA has been broken for some time. It is recommended to use a length on the higher end of the range, but do keep in mind that computation will take longer.</dd>
				</dd><br />
				<dt>Elliptic Curve Diffie-Hellman (ECDH)</dt>
				<dd>Diffie-Hellman is a key negotiation protocol used to allow two parties to agree on a shared secret to use for symmetric encryption. Both parties first generate a private key and then use that key with a generator, G, to generate a public key. The key generation can be described using the following formulae:<br />
					<span class="code">
						// Public Key Generation<br />
						Alice:	alice private key * G = alice public key<br />
						Bob:	bob private key * G = bob public key
						</span><br />
					In the case of elliptic curve Diffie-Hellman G is a base point on the elliptic curve and the public key is the result of multiplying that point by the private key. The properties of this algorithm are such that, for both parties, multiplying your private key by the other party&apos;s public key yields the same shared secret.<br />
					<span class="code">
						// Secret Computation<br />
						Alice:	alice private key * bob public key = secret<br />
						Bob:	bob private key * alice public key = secret<br />
						Symmetric Encryption Key = KDF(secret)<br />
						// KDF = some key derivation function
						</span><br />
					The ECDH algorithm provided by this library uses the SECT233k1 elliptic curve. It has a degree of 233 bits and a base order of 232 bits (29 bytes) which is also the maximum length of the private key. It provides an effective security level rivaling that of 2048 bit RSA and standard Diffie-Hellman. Why is the elliptic curve variant so much more secure? Firstly, the basis of elliptic curve cryptography (how curves are structured algebraically over finite fields) lends itself to the creation of keys that are more mathemtically-complicated to crack than the prime factorization methods of cracking non-elliptic curve keys. Also the keyspace over such a finite field is typically larger than the keyspace of primes of the same bit width.
					</dd>
			</dl>
			<div class="major-header">Macros</div>
			<div class="function-doc">#define AES_CTR_NONCELEN(len)   ((0x0f & len)&lt;&lt;4)</div>
			<p>Defines a macro for passing a nonce (salt) length to aes_init's flags parameter.</p>
			<div class="function-doc">#define AES_CTR_COUNTERLEN(len) ((0x0f & len)&lt;&lt;8)</div>
			<p>Defines a macro for passing a counter length to aes_init's flags parameter.</p>
			<div class="function-doc">#define AES_BLOCKSIZE	16</div>
			<p>Defines the block size of the AES cipher.</p>
			<div class="function-doc">#define AES_IVSIZE AES_BLOCKSIZE</div>
			<p>Defines the length of the AES initialization vector.</p>
			<div class="function-doc">#define aes_outsize(len) \<br />
				((((len)%AES_BLOCKSIZE)==0) ? (len) + AES_BLOCKSIZE : (((len)>>4) + 1)<<4)</div>
			<p>Defines a macro to return the necessary length for a padded AES plaintext.</p>
			<div class="function-doc">#define aes_extoutsize(len) \<br />(aes_outsize((len)) + AES_IVSIZE)</div>
			<p>Defines a macro to return the necessary length for a padded AES plaintext plus a single block for the IV.</p>
			<div class="function-doc">#define ECDH_PRIVKEY_SIZE   32</div>
			<p>Defines the length of the ECDH private key.</p>
			<div class="function-doc">#define ECDH_PUBKEY_SIZE   32</div>
			<p>Defines the length of the ECDH public key.</p>
			<div class="major-header">Enumerations</div>
			<div class="function-doc">enum aes_cipher_modes { AES_MODE_CBC, AES_MODE_CTR };</div>
			<p>Defines supported AES cipher modes.</p>
			<div class="function-doc">enum aes_padding_schemes { PAD_PKCS7, PAD_DEFAULT = PAD_PKCS7, PAD_ISO2 = 4 };</div>
			<p>Defines supported padding schemes for AES CBC mode</p>
			<div class="function-doc">typedef enum { AES_OK, AES_INVALID_ARG, AES_INVALID_MSG, AES_INVALID_CIPHERMODE, AES_INVALID_PADDINGMODE, AES_INVALID_CIPHERTEXT, AES_INVALID_OPERATION } aes_error_t;</div>
			<p>Defines possible responses codes from calls to the AES API.</p>
			<div class="function-doc">typedef enum { RSA_OK, RSA_INVALID_ARG,  RSA_INVALID_MSG, RSA_INVALID_MODULUS, RSA_ENCODING_ERROR } rsa_error_t;</div>
			<p>Defines possible response codes from calls to the RSA API
			</p>
			<div class="function-doc">typedef enum { ECDH_OK, ECDH_INVALID_ARG,  ECDH_PRIVKEY_INVALID, ECDH_RPUBKEY_INVALID } ecdh_error_t;</div>
			<p>Defines possible response codes from calls to the ECDH API
			</p>
			<div class="major-header">Structs</div>
			<div class="function-doc">typedef struct aes_ctx;</div>
			<p>Defines state data for an AES context.</p>
			<div class="function-doc">typedef struct ecdh_ctx;</div>
			<p>Defines state data for an ECDH context.</p>
			<div class="major-header">Functions</div>
			<div class="function-doc">bool csrand_init(bool sampling_mode);</div>
			<p>Initializes the secure RNG.<br /><br />
				<span class="param">sampling_mode</span>: A flag specifying the sampling mode. See below.<br />
				<span class="return">output</span>: True if success, False if failed
				<span class="more-info">
					SAMPLING_THOROUGH ensures a more entropic source, but takes longer (~4s).<br />
					SAMPLING_FAST takes less time (~2s) but may not select the most entropic bit.
				</span>
			</p>
			<div class="function-doc">uint32_t csrand_get(void);</div>
			<p>Returns a securely random 32-bit (4 byte) integer.<br /><br />
			<span class="return">output</span>: A 32-bit random integer
			</p>
			<div class="function-doc">bool csrand_fill(void* buffer, size_t size);</div>
			<p>Fills a buffer with securely random bytes.<br /><br />
				<span class="param">buffer</span>: Pointer to a buffer to fill with random bytes<br />
				<span class="param">size</span>: Length of the buffer<br />
				<span class="return">output</span>: True if success, False if failed
			</p>
			<div class="function-doc">aes_error_t aes_init(aes_ctx* ctx, const void* key, size_t keylen, const void* iv, uint24_t flags);</div>
			<p>Initializes a stateful and one-directional AES context.<br /><br />
			<span class="param">ctx</span>: Pointer to an AES context<br />
			<span class="param">key</span>: Pointer to the key to use with the AES context<br />
			<span class="param">keylen</span>: Length of the key, in bytes<br />
			<span class="param">iv</span>: Pointer to a 16-byte initialization vector (salt)<br />
			<span class="param">flags</span>: A series of cipher options bitwise-ORd together.<br />
			<span class="return">output</span>: An aes_error_t indicating the status of the AES operation<br />
				<span class="more-info"><span style="font-weight:bold;">Cipher Options Flags</span><br />
					Cipher Mode: AES_MODE_CTR, AES_MODE_CBC<br />
					For AES CBC mode: PAD_DEFAULT, PAD_PKCS7, PAD_ISO2<br />
					For AES CTR mode: AES_CTR_NONCELEN(len), AES_CTR_COUNTERLEN(len)
					</span>

			</p>
			<div class="function-doc">aes_error_t aes_encrypt(const aes_ctx* ctx, const void* plainrtext, size_t len, void* ciphertext);</div>
			<p>Encrypts a stream of data and updates the AES context such that (1) it will return AES_INVALID_OPERATION if used with decryption, and (2) you can pass the next stream of data to aes_encrypt() using the same context.<br /><br />
			<span class="param">ctx</span>: Pointer to AES context<br />
			<span class="param">plaintext</span>: Pointer to stream of data to encrypt<br />
			<span class="param">len</span>: Length of data to encrypt<br />
			<span class="param">ciphertext</span>: Pointer to buffer to write encrypted data to<br />
			<span class="return">output</span>: An aes_error_t indicating the status of the AES operation
			</p>
			<div class="function-doc">aes_error_t aes_decrypt(const aes_ctx* ctx, const void* ciphertext, size_t len, void* plaintext);</div>
			<p>Decrypts a stream of data and updates the AES context such that (1) it will return AES_INVALID_OPERATION if used with encryption, and (2) you can pass the next stream of data to aes_decrypt() using the same context.<br /><br />
			<span class="param">ctx</span>: Pointer to AES context<br />
			<span class="param">plaintext</span>: Pointer to stream of data to decrypt<br />
			<span class="param">len</span>: Length of data to decrypt<br />
			<span class="param">ciphertext</span>: Pointer to buffer to write decrypted data to<br />
			<span class="return">output</span>: An aes_error_t indicating the status of the AES operation
			</p>
			<div class="function-doc">rsa_error_t rsa_encrypt(const void* msg, size_t msglen, void* ciphertext, const void* pubkey, size_t keylen, uint8_t oaep_hash_alg);</div>
			<p>Encrypts a message using the RSA algorithm, applying the <span style="font-style:italic;">Optimal Asymmetic Encryption Padding</span> scheme (OAEPv2.2) prior to encryption.<br /><br />
			<span class="param">msg</span>: Pointer to message to encrypt<br />
			<span class="param">msglen</span>: Length of message to encrypt<br />
			<span class="param">ciphertext</span>: Pointer to buffer to write encrypted message to<br />
			<span class="param">pubkey</span>: Pointer to public modulus to encrypt with<br />
			<span class="param">keylen</span>: Length, in bytes, of the public modulus<br />
			<span class="return">output</span>: An rsa_error_t indicating the status of the RSA operation
			</p>
			<div class="function-doc">ecdh_error_t ecdh_keygen(ecdh_ctx* ctx, bool (*randfill)(void* buffer, size_t size));</div>
			<p>Generates an ECDH public key given an ECDH context. If <span style="font-weight:bold">randfill</span> is provided, the private key is filled with random bytes prior to public key generation.<br /><br />
			<span class="param">ctx</span>: Pointer to an ECDH context<br />
			<span class="param">randfill</span>: Pointer to a function used to fill a buffer with random bytes.<br />&emsp;&emsp;<span style="font-weight:bold">csrand_fill</span> is recommended for this.<br />
			<span class="return">output</span>: An ecdh_error_t indicating the status of the ECDH operation<br />
			&emsp;&emsp;The context is updated with the public key, accessible at ctx.pubkey.<br />
			&emsp;&emsp;The private key is also accessible at ctx.privkey.
			<span class="more-info">
				If you pass NULL for <span style="font-weight:bold;">randfill</span>, it will be assumed that you have generated and random-filled the private key yourself. Do not do this if you do not know what you are doing. If you choose to generate your own private key, the length must be between half the base order and the base order, in bits (116 - 232). This is 15-29 bytes. Using a smaller key results in a lower effective security level.<br />
				Do not edit the context manually after calling this function, you will corrupt the state.<br />
				Only access these structure members for reading out the public key.
			</span>
			</p>
			<div class="function-doc">ecdh_error_t ecdh_secret(ecdh_ctx* ctx, const uint8_t* rpubkey, uint8_t* secret);</div>
			<p>Generates a shared secret given an ECDH context and a remote public key.<br />
			Uses the cofactor variant of ECDH. SECT233k1 has a cofactor of 4.<br /><br />
			<span class="param">ctx</span>: Pointer to an ECDH context<br />
			<span class="param">rpubkey</span>: Pointer to a remote public key<br />
			<span class="param">secret</span>: Pointer to buffer to write the secret to<br />
			<span class="return">output</span>: An ecdh_error_t indicating the status of the ECDH operation<br />
			<span class="more-info">
				Do not edit the context manually, you will corrupt the state.<br />
				Do not use the generated secret directly for symmetric encryption. Pass it to a KDF or cryptographic hash to generate a digest and use that as your encryption key.
			</span>
			</p>
			<div class="major-header">Addendum: Authenticated Encryption</div>
			<p>Authenticated encryption is an encryption scheme that produces a ciphertext that is not only obfuscated but also has its integrity and authenticity verifiable. This can be accomplished in a few ways, the most common of which are: (1) appending a signature, hash, or keyed hash to a message, and (2) implementing a cipher mode that integrates authentication.</p>
			<p>#2 above is not implemented in CryptX. Most of the authenticating cipher modes are computationally-intensive without hardware acceleration and may not be feasible for use on the TI-84+ CE. While consid- eration is being given to potentially adding a cipher mode such as OCB or GCM if a sufficiently-optimized implementation for this platform can be found (or devised), it is possible to construct a ciphertext guarded against tampering by using method #1, which this library does provide for.</p>
			<p>It is recommended that whenever you are sending data you need to be truly secure with this library, you always embed a keyed hash into the message that the recipient can validate. This functionality is provided by the HMAC implementation shown earlier in this document. Proper application of HMAC for ciphertext integrity requires the following considerations:</p>
			<ul>
				<li>Initialization vector/nonce blocks for encryption are securely pseudo-random.</li>
				<li>Encryption and HMAC keys are also securely pseudo-random and are long enough to be considered secure. Minimum key sizes recommended are 16 bytes.</li>
				<li>You are not using your encryption key as your HMAC key or vice versa. There are attack vectors that result from using the same key for encryption and authentication.</li>
				<li>Append a keyed hash (HMAC) of the initialization vector/nonce, encrypted message, and any other associated data such as packet headers to the outgoing message. On the receiving side, validate the HMAC before decryption and reject any message that does not authenticate. The HMAC key can be an application secret known to both parties or a generated nonce shared alongside the AES encryption key using RSA or another public key encryption method.</li>
			</ul>
			<span style="font-weight:bold;">Example of authenticated encryption, CryptX. by Anthony Cagliano</span>
			<pre class="code"><code class="language-c">
// this assumes that the AES secret ‘aes_key‘ and the HMAC secret ‘hmac_key‘
// have been negotiated beforehand.

// let’s send a simple ascii string
char* msg = "The daring fox jumped over the moon."

// the header is a size word, containing size of string plus our IV
// header can really be whatever you want, but some arbitrary nonsense as an example
size_t header = sizeof(msg)+AES_IVSIZE;

// allocate the memory we need
uint8_t iv[AES_IVSIZE];
uint8_t hmac_digest[SHA256_DIGEST_LEN];
aes_ctx ctx;
hmac_ctx hmac;

// !!!! NEVER PROCEED IF csrand_init() FAILS !!!
if(!csrand_init()) return false;
csrand_fill(iv, AES_IVSIZE);

// initialize AES context with mode , key , and iv
aes_init(&ctx, aes_key, sizeof aes_key, iv, AES_MODE_CTR);

// encrypt message
// aes_encrypt supports in-place encryption
aes_encrypt(&ctx, msg, strlen(msg), msg);

// hash everything you are sending, except the hash itself
hmac_init(&hmac, hmac_key, sizeof hmac_key, SHA256);
hmac_update(&hmac, &header, sizeof header);
hmac_update(&hmac, iv, sizeof iv);
hmac_update(&hmac, msg, strlen(msg));
hmac_final(&hmac, hmac_digest);

// ps_queue/send are psuedo functions implying queueing data to send
// and then sending it
ps_queue(&header, sizeof header);
ps_queue(iv, sizeof iv);
ps_queue(msg, sizeof msg);
ps_queue(hmac_digest, sizeof hmac_digest);
ps_send();
			</code></pre>
			<hr />
			<iframe src="scripts/rtd-msg.html" style="width:100%; height:50px; border:none;"></iframe>
			<br />
		</div></div>
	</body>
	<script>hljs.highlightAll();</script>
</html>

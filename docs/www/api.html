<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Overview &mdash; CryptX  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/proof.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CryptX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="static/analysis.html">Analysis &amp; Overview</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CryptX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Overview</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p id="api">This document is meant to serve as both an overview of the library API (through extensively-commented code samples) and an appreviated crash course on cryptography. This is so that users gain an understanding of why and how they would use the library’s modules properly instead of just copypasta’ing code. Usage of this library is more likely to be done properly if users know why things are done certain ways.</p>
<p>Links to detailed function documentation for each module are available at end of each section of this page.</p>
<div class="section" id="api-overview">
<h1>API Overview<a class="headerlink" href="#api-overview" title="Permalink to this headline"></a></h1>
<p>You must include the library’s header in any file within your project where a function from the library is used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cryptx.h&gt;</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="section" id="integrity-verification">
<h2>Integrity Verification<a class="headerlink" href="#integrity-verification" title="Permalink to this headline"></a></h2>
<p>An important aspect of securing information is the ability to ensure that information has not been tampered with. This tampering can occur in long-term storage (ex: a bad actor attempts to modify a file on a system) or in transit (ex: a bad actor attempts to modify the contents of an Internet packet). A secure means of communication (or storage) needs the ability to detect such tampering.</p>
<p><strong>Hashes</strong> and <strong>HMAC</strong> are tools that assist with integrity verification. The standard hash produces a fixed-length value (called a <em>digest</em>) from an arbitrary-length stream of data. Because secure hashes have a negligibly low chance of collision (two different inputs producing the same output), they can detect changes to a stream of data. An HMAC works similarly, except it transforms the hash state using a key that is generally known only to authorized parties prior to hashing the data. This means that an HMAC can only be generated or validated by an authorized party. A HMAC is also sometimes referred to as a <em>keyed hash</em>.</p>
<p><strong>Using the Hash API</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World!&quot;</span><span class="w">   </span><span class="c1">// String to hash</span>
<span class="n">cryptx_hash_ctx</span><span class="w"> </span><span class="n">hash</span><span class="p">;</span><span class="w">         </span><span class="c1">// Declare hash context</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cryptx_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">))</span><span class="w">  </span><span class="c1">// Initialize hash context</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// exit if fails</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">digest</span><span class="p">[</span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="p">];</span><span class="w">  </span><span class="c1">// Create a buffer of correct size for hash</span>

<span class="n">cryptx_hash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">));</span><span class="w">  </span><span class="c1">// Hash string</span>
<span class="n">cryptx_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">digest</span><span class="p">);</span><span class="w">    </span><span class="c1">// Return digest</span>
<span class="c1">// `digest` now contains the hash value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/hash.html#hash"><span class="std std-ref">view hash documentation</span></a></p></li>
</ul>
<p><strong>Using the HMAC API</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World!&quot;</span><span class="w">   </span><span class="c1">// String to hash</span>
<span class="n">cryptx_hmac_ctx</span><span class="w"> </span><span class="n">hash</span><span class="p">;</span><span class="w">         </span><span class="c1">// Declare hmac context</span>
<span class="cp">#define HMAC_KLEN 16</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">HMAC_KLEN</span><span class="p">];</span><span class="w">       </span><span class="c1">// Define HMAC key buffer</span>

<span class="c1">// generate random key</span>
<span class="n">cryptx_csrand_fill</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">HMAC_KLEN</span><span class="p">);</span>

<span class="c1">// intialize HMAC for given key and algorithm</span>
<span class="n">cryptx_hmac_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">HMAC_KLEN</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">digest</span><span class="p">[</span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="p">];</span><span class="w">  </span><span class="c1">// Create a buffer of correct size for hash</span>

<span class="n">cryptx_hmac_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">));</span><span class="w">  </span><span class="c1">// Hash string</span>
<span class="n">cryptx_hmac_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">digest</span><span class="p">);</span><span class="w">    </span><span class="c1">// Return digest</span>
<span class="c1">// `digest` now contains the hmac value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/hmac.html#hmac"><span class="std std-ref">view hmac documentation</span></a></p></li>
</ul>
<p><strong>Using the MGF1 API</strong></p>
<p><strong>MGF1</strong> (Mask-Generation Function v1) is a hash-derived function that allows for a digest of arbitrary length to be returned from a data stream of given size. Its usage is similar to the hash API above.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World!&quot;</span><span class="w">   </span><span class="c1">// String to hash</span>
<span class="cp">#define MGF1BUF_LEN 32</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">mgf1buf</span><span class="p">[</span><span class="n">MGF1BUF_LEN</span><span class="p">];</span>

<span class="n">cryptx_hash_mgf1</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">),</span><span class="w"> </span><span class="n">mgf1buf</span><span class="p">,</span><span class="w"> </span><span class="n">MGF1BUF_LEN</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">);</span>
<span class="c1">// `mgf1buf` now contains the digest value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="xref std std-ref">view mgf1 documentation</span></p></li>
</ul>
<p><strong>Comparing two Digests Securely</strong></p>
<p>A cryptography library needs a safe way to compare two digests to determine if they are the same. The <cite>memcmp</cite> and <cite>strcmp/strncmp</cite> functions in the toolchain are not timing-safe; they return as soon as a mismatch is found. This causes slight variations in execution time that may reveal which character(s) of the digest are correct. This library provides a variant of this function in which the full length provided is parsed regardless of where the first mismatch is leading to no variance in execution time. Such a function is referred to as a <em>constant-time implementation</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RECV_BUF_LEN 1024</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">RECV_BUFF_LEN</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">packet_len</span><span class="p">;</span>

<span class="c1">// get incoming data into `buf`, update `packet_len`</span>
<span class="c1">// assume last 32 bytes of `buf` are a hash of the rest</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">packet_len</span><span class="p">);</span>

<span class="c1">// hash the data on receiving end</span>
<span class="n">cryptx_hash_ctx</span><span class="w"> </span><span class="n">hash</span><span class="p">;</span>
<span class="n">cryptx_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">t_digest</span><span class="p">[</span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="p">];</span>
<span class="n">cryptx_hash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">packet_len</span><span class="mi">-32</span><span class="p">);</span>
<span class="n">cryptx_hash_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">t_digest</span><span class="p">);</span>

<span class="c1">// compare computed digest with one embedded in packet</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cryptx_digest_compare</span><span class="p">(</span><span class="n">t_digest</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">packet_len</span><span class="mi">-32</span><span class="p">],</span><span class="w"> </span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// data failed integrity check</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="xref std std-ref">view digest_compare documentation</span></p></li>
</ul>
<p><strong>Converting a Digest to a String</strong></p>
<p>Lastly, for debugging purposes and occasionally for UI purposes it may be desired to display a digest to the user as a readable string. A function is provided by this library to convert a binary digest into its printable hex-string equivalent.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// assume some digest is in `digest`</span>
<span class="kt">char</span><span class="w"> </span><span class="n">hexstr</span><span class="p">[</span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="n">cryptx_digest_tostring</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">.</span><span class="n">digest_len</span><span class="p">,</span><span class="w"> </span><span class="n">hexstr</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">hexstr</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="xref std std-ref">view digest_tostring documentation</span></p></li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="key-derivation-management">
<h2>Key Derivation &amp; Management<a class="headerlink" href="#key-derivation-management" title="Permalink to this headline"></a></h2>
<p>Encryption (and HMAC) require secure key generation and management. As mentioned before the strength of your encryption system depends on the security of your keys. This includes not only that the key be generated using a secure random generator or other secure algorithm but also that the user have a means for protecting any keys that need to be persistently stored (such as for database or file encryption).</p>
<p>CryptX supports two methods of key generation: random and password-derived. To generate a random key, simply use the secure random generator as documented above, namely <em>cryptx_csrand_fill</em>. For a password-derived key there is an implementation of <em>hmac_pbkdf2</em> in CryptX. You would use it like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// `prompt_user` is a psuedo-function implying a text-input UI</span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">passwd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prompt_user</span><span class="p">();</span>

<span class="c1">// declare buffer for AES key</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">aes_key</span><span class="p">[</span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">];</span>

<span class="c1">// declare buffer for PBKDF2 salt (random bytes)</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">pbkdf2_salt</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">    </span><span class="c1">// min length recommended</span>
<span class="n">cryptx_csrand_fill</span><span class="p">(</span><span class="n">pbkdf2_salt</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>

<span class="cp">#define PBKDF2_COST   1000</span>
<span class="n">cryptx_hmac_pbkdf2</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">passwd</span><span class="p">),</span><span class="w">  </span><span class="c1">// password and length of password</span>
<span class="w">                    </span><span class="n">pbkdf2_salt</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w">        </span><span class="c1">// salt and length of salt</span>
<span class="w">                    </span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">,</span><span class="w"> </span><span class="c1">// key outbuf and length of key to gen</span>
<span class="w">                    </span><span class="n">PBKDF2_COST</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">);</span><span class="w">   </span><span class="c1">// # times to iterate hash and hash alg to use</span>

<span class="c1">// aes_key now contains a password-derived secure key</span>
<span class="c1">// dump salt somewhere and require user input password to decrypt whatever</span>
<span class="c1">// this key is encrypting. Note that if user forgets password, data is</span>
<span class="c1">// not recoverable.</span>
</pre></div>
</div>
<p>No matter how much people on the Internet like to claim that tech giants have your passwords and data, information security standards (like PCI-DSS, GDPR, and others) mandate that public-facing secure services–especially those that store sensitive personal information–implement these cryptosystems and store credentials using non-reversible algorithms (such as a hash) that save enough information to verify a credential but not enough to reveal it. This means that unless you are able to supply your password to generate a key for decryption, your data is VERY hard to recover. That is the nature of encryption, and it all cascades to a simple, unalienable fact that your information–be it your passwords, security keys, or other manner of security–is your responsibility. Remember that the next time you want to yell at a technican because you forgot your password.</p>
</div>
<hr class="docutils" />
<div class="section" id="symmetric-encryption">
<h2>Symmetric Encryption<a class="headerlink" href="#symmetric-encryption" title="Permalink to this headline"></a></h2>
<p>Data obfuscation is another layer of information securty which is achieved through the use of encryption, or the rendering of information indecipherable for anyone without the key used to encrypt it. Encryption can be intended to protect information in long-term storage as well as to protect information in transit between two authorized endpoints.</p>
<p><strong>AES (Advanced Encryption Standard)</strong></p>
<p>AES is currently the gold standard for secure data transmission and storage. The thing that makes AES great is that it is fast and secure. Running it on the calculator takes barely any time. However, AES does have a number of operational parameters and constraints that can make using it a bit complicated. We’ll try to summarize that information as simply as possible.</p>
<ul class="simple">
<li><p>AES has three variants defined by key length:</p>
<ul>
<li><p>AES-128 (128 bit keys, 10 rounds (repetitions) of encryption)</p></li>
<li><p>AES-192 (192 bit keys, 12 rounds of encryption)</p></li>
<li><p>AES-256 (256 bit keys, 14 rounds of encryption)</p></li>
<li><p><strong>Using 256 bit keys is recommended.</strong></p></li>
</ul>
</li>
<li><p>CryptX supports three operational cipher modes:</p>
<ul>
<li><p>Cyclic Block Chaining (CBC)</p></li>
<li><p>Counter (CTR)</p></li>
<li><p>Galois Counter (GCM)</p></li>
<li><p><strong>Using GCM is recommended as it integrates integrity verification into the output.</strong></p></li>
</ul>
</li>
<li><p>AES uses an <em>initialization vector</em> (IV) which is a 16-byte buffer of random bytes specific to the session (or message for GCM mode) used to give the encryption randomized output.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// ** As Sender **</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;The dog jumped over the fox!&quot;</span><span class="p">;</span><span class="w">   </span><span class="c1">// string to send</span>
<span class="n">cryptx_aes_ctx</span><span class="w"> </span><span class="n">aes</span><span class="p">;</span><span class="w">   </span><span class="c1">// declare empty AES context</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">aes_key</span><span class="p">[</span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">];</span><span class="w">   </span><span class="c1">// declare AES key buffer</span>
<span class="n">cryptx_csrand_fill</span><span class="p">(</span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">);</span><span class="w"> </span><span class="c1">// random key</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">iv</span><span class="p">[</span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">];</span><span class="w">    </span><span class="c1">// declare IV</span>
<span class="n">cryptx_csrand_fill</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">);</span><span class="w">   </span><span class="c1">// random iv</span>

<span class="k">if</span><span class="p">(</span><span class="n">cryptx_aes_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">,</span>
<span class="w">                  </span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_GCM_FLAGS</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// AES initialization error</span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">msg_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">// encrypt in-place is valid</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_aes_encrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">msg_len</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// AES encryption failed</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="n">auth_tag</span><span class="p">[</span><span class="n">CRYPTX_AES_AUTHTAG_SIZE</span><span class="p">];</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_aes_digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="n">auth_tag</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// AES digest return failed</span>

<span class="c1">// at this point the AES context is marked invalid until initialized again with a new IV.</span>
<span class="c1">// See warning below</span>

<span class="c1">// send receiver all information necessary to authenticate and decrypt</span>
<span class="n">network_send</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">);</span>
<span class="n">network_send</span><span class="p">(</span><span class="n">auth_tag</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_AUTHTAG_SIZE</span><span class="p">);</span>
<span class="n">network_send</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">msg_len</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/aes.html#aes"><span class="std std-ref">view AES documentation</span></a></p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// ** As Receiver **</span>

<span class="c1">// Assume that `aes_key` has already been exchanged</span>
<span class="n">cryptx_aes_ctx</span><span class="w"> </span><span class="n">aes</span><span class="p">;</span><span class="w">   </span><span class="c1">// Define empty AES context</span>

<span class="c1">// Allocate buffer for incoming packets</span>
<span class="cp">#define RECVBUF_LEN 1024</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">RECVBUF_LEN</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">buf_len</span><span class="p">;</span>

<span class="c1">// Receive message to `buf` update `buf_len`</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf_len</span><span class="p">);</span>

<span class="c1">// mirroring sent data above, IV is first 16 bytes of `buf`</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_aes_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">,</span>
<span class="w">                  </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_GCM_FLAGS</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// AES initialization error</span>

<span class="c1">// these will be used multiple times</span>
<span class="c1">// msg follows authtag and is rest of buf_len</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">CRYPTX_AES_AUTHTAG_SIZE</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">msg_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">CRYPTX_AES_AUTHTAG_SIZE</span><span class="p">;</span>

<span class="c1">// authenticate incoming message first</span>
<span class="c1">// authtag is 16 bytes and follows IV</span>
<span class="c1">// REFUSE DECRYPTION IF INVALID</span>
<span class="k">if</span><span class="o">!</span><span class="p">(</span><span class="n">cryptx_aes_verify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">msg_len</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">CRYPTX_AES_IV_SIZE</span><span class="p">]))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// return if auth fails</span>

<span class="k">if</span><span class="p">(</span><span class="n">cryptx_aes_decrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aes</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">msg_len</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// AES decryption failed</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/aes.html#aes"><span class="std std-ref">view AES documentation</span></a></p></li>
</ul>
</div>
<div class="section" id="public-key-cryptography-key-exchange-protocols">
<h2>Public Key Cryptography &amp; Key Exchange Protocols<a class="headerlink" href="#public-key-cryptography-key-exchange-protocols" title="Permalink to this headline"></a></h2>
<p>AES is great but has a major shortcoming. You need a way to agree upon the secret on both sides of the secure session prior to starting to encrypt messages using it. If you send the key in the clear (unencrypted), what’s the point of the encryption then? This is where <strong>key exchange protocols</strong> enter the discussion. These are algorithms, some encryption methods and some mathematical computations, that allow two endpoints to agree on a shared secret for symmetric encryption without leaking the secret.</p>
<p><strong>Rivest-Shamir-Adleman (RSA) Encryption</strong></p>
<p>The first option supported within CryptX is also one of the most commonly used on the Internet today. It is an encryption system developed by computer scientists Ron Rivest and Adi Shamir and mathematician Leonard Adleman–and named for them as well. RSA is a form of <em>asymmetric encryption</em> (encryption system that uses two opposing keys, a public one to encrypt and a private one to decrypt). Because the public key is used for encryption RSA is also a form of <em>public key cryptography</em>.</p>
<p>How does that benefit us? Imagine you, using your web browser, attempt to connect to some secure website. Upon attempt to connect, the website sends you a public key that you can use to encrypt messages for it. You encrypt an AES secret using this public key and ship it to the website. The website decrypts that with its own private key. You and the website now have the AES secret and it was not leaked in transit (assuming the developer did things right). Go-go-gadget AES.</p>
<p>Using RSA on calculator with CryptX is quite simple–it just takes some time. Most key exchange protocols use hefty mathematics and the calculator takes a lot more than a few milliseconds to pull them off. 2048-bit RSA takes about 8 seconds to complete. Additionally, this implementation automatically applies the <em>Optimal Asymmetric Encryption Padding (OAEP) v2.2</em> encoding scheme. This extends the length of the message to one bit less than the length of the public modulus and incorporates randomness into the encryption.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RECVBUF_LEN 1024</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">[</span><span class="n">RECVBUF_LEN</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">recv_len</span><span class="p">;</span>

<span class="c1">// read incoming to `recv_buf` update `recv_len`</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_len</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">rsa_pubkey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">;</span>

<span class="c1">// define a buffer large enough to hold ciphertext</span>
<span class="c1">// an encoded, RSA-encrypted message is the same length as the public modulus</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">rsa_ciphertext</span><span class="p">[</span><span class="n">recv_len</span><span class="p">];</span>

<span class="c1">// generate AES secret</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">aes_key</span><span class="p">[</span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">];</span>
<span class="n">cryptx_csrand_fill</span><span class="p">(</span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">cryptx_rsa_encrypt</span><span class="p">(</span><span class="n">aes_key</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_AES_256_KEYLEN</span><span class="p">,</span>
<span class="w">                      </span><span class="n">rsa_pubkey</span><span class="p">,</span><span class="w"> </span><span class="n">recv_len</span><span class="p">,</span>
<span class="w">                      </span><span class="n">rsa_ciphertext</span><span class="p">,</span><span class="w"> </span><span class="n">SHA256</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// some RSA error occurred</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/rsa.html#rsa"><span class="std std-ref">view RSA documentation</span></a></p></li>
</ul>
<p><strong>Elliptic Curve Diffie-Hellman (ECDH) Key Exchange</strong></p>
<p>The second option supported within CryptX is perhaps not as widely used (and fairly new) but arguably more secure. It is an encryption system based upon the less secure Diffie-Hellman key exchange protocol, but using elliptic curve arithmetic instead of standard modular arithmetic. The behavior of an elliptic curve over a Galois field lends to a cryptosystem that is much harder to crack.</p>
<p>Just like with RSA, using this on the calculator is quite simple–but time-consuming. Each function–key generation and secret computation–takes about 12-14 seconds to complete.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ec_privkey</span><span class="p">[</span><span class="n">CRYPTX_ECDH_PRIVKEY_LEN</span><span class="p">];</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ec_pubkey</span><span class="p">[</span><span class="n">CRYPTX_ECDH_PUBKEY_LEN</span><span class="p">];</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">ec_secret</span><span class="p">[</span><span class="n">CRYPTX_ECDH_SECRET_LEN</span><span class="p">];</span>

<span class="c1">// generates a random private key and associated public key</span>
<span class="c1">// supports SECT233k1 elliptic curve</span>
<span class="c1">// these keys are compatible with both ECDH and later ECDSA</span>
<span class="n">cryptx_ec_keygen</span><span class="p">(</span><span class="n">ec_privkey</span><span class="p">,</span><span class="w"> </span><span class="n">ec_pubkey</span><span class="p">);</span>

<span class="c1">// send your private key to the remote host</span>
<span class="n">network_send</span><span class="p">(</span><span class="n">ec_pubkey</span><span class="p">,</span><span class="w"> </span><span class="n">CRYPTX_ECDH_PUBKEY_LEN</span><span class="p">);</span>

<span class="c1">// get remote host&#39;s public key into `ec_pubkey`. Size known.</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">ec_pubkey</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// compute secret</span>
<span class="n">cryptx_ecdh_secret</span><span class="p">(</span><span class="n">ec_privkey</span><span class="p">,</span><span class="w"> </span><span class="n">ec_pubkey</span><span class="p">,</span><span class="w"> </span><span class="n">ec_secret</span><span class="p">);</span>

<span class="c1">// ECDH computations have the property that given:</span>
<span class="c1">// keypairs: prA, puA and prB, puB, consisting of:</span>
<span class="c1">// private keys: prA, prB and</span>
<span class="c1">// public keys: puA, puB it follows that:</span>
<span class="c1">// prA * puB == prB * puA.</span>
<span class="c1">// This allows both parties to compute the same shared secret that is secure so</span>
<span class="c1">// long as the private keys are not leaked.</span>

<span class="c1">// it is advised to HASH `ec_secret` and not use it as it.</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/ecc.html#ec"><span class="std std-ref">view elliptic curve documentation</span></a></p></li>
</ul>
</div>
<div class="section" id="cryptographic-encoding-formats">
<h2>Cryptographic Encoding Formats<a class="headerlink" href="#cryptographic-encoding-formats" title="Permalink to this headline"></a></h2>
<p>The <em>Public Key Cryptography Standards (PKCS)</em> defines, if you can believe it, standards for the encoding of public keys in storage and transit. The two most commonly used encoding formats are <em>Abstract Syntax Notation One (ASN.1)</em> and <em>Base64</em>. Do not confuse encryption with encoding. Encoding is merely a method of expressing information in plain-text format. It does not prevent unauthorized parties from reading or modifying the data.</p>
<p><strong>Abstract Syntax Notation One (ASN.1)</strong></p>
<p>Many cryptographic structures are encoded using <em>Distinguished Encoding Rules (DER)</em> which is a serialization format of ASN.1 standardized for cryptography. See the example below which expresses the encoding of a public key from <em>Public Key Cryptography Standards #8 (PKCS#8)</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PublicKeyInfo</span><span class="w"> </span><span class="o">::=</span><span class="w"> </span><span class="n">SEQUENCE</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">algorithm</span><span class="w"> </span><span class="n">AlgorithmIdentifier</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">SEQUENCE</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">algorithm</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">OBJECT</span><span class="w"> </span><span class="n">IDENTIFIER</span><span class="p">,</span>
<span class="w">                </span><span class="n">parameters</span><span class="w"> </span><span class="n">ANY</span><span class="w"> </span><span class="n">DEFINED</span><span class="w"> </span><span class="n">BY</span><span class="w"> </span><span class="n">algorithm</span><span class="w"> </span><span class="n">OPTIONAL</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">PublicKey</span><span class="w"> </span><span class="n">BIT</span><span class="w"> </span><span class="n">STRING</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RECVBUF_LEN 1024</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">[</span><span class="n">RECVBUF_LEN</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">recv_len</span><span class="p">;</span>

<span class="c1">// read incoming to `recv_buf` update `recv_len`</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_len</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">rsa_pubkey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">;</span>

<span class="c1">// ** Decode DER-encoded structure **</span>
<span class="c1">// decode parent SEQUENCE, tag_data and tag_datalen are pointers to data</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">tag_data</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">tag_datalen</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_asn1_decode</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">,</span><span class="w"> </span><span class="n">recv_len</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag_datalen</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tag_data</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// decoding error, do something to handle</span>

<span class="c1">// `PublicKey` object is actually a BIT STRING-encoded DER structure</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">keydata</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">keylen</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_asn1_decode</span><span class="p">(</span><span class="n">tag_data</span><span class="p">,</span><span class="w"> </span><span class="n">tag_datalen</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keylen</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keydata</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// decoding error, do something to handle</span>

<span class="c1">// Decode PKCS#1 Public Key structure</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">keystruct</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">keystruct_len</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_asn1_decode</span><span class="p">(</span><span class="n">keydata</span><span class="p">,</span><span class="w"> </span><span class="n">keylen</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keystruct_len</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keystruct</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// decoding error, do something to handle</span>

<span class="c1">// `keyinner` now contains two ASN.1 encoded objects, the modulus and the exponent</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">key_modulus</span><span class="p">;</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">key_modulus_size</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cryptx_asn1_decode</span><span class="p">(</span><span class="n">keystruct</span><span class="p">,</span><span class="w"> </span><span class="n">keystruct_len</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key_modulus_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key_modulus</span><span class="p">))</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w">   </span><span class="c1">// decoding error, do something to handle</span>

<span class="c1">// We only need modulus, library exponent is hardcoded to 65537.</span>
<span class="c1">// In theory can you can *validate* that the exponent is supported</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/encoding.html#encoding"><span class="std std-ref">view ASN.1 documentation</span></a></p></li>
</ul>
<p><strong>Base64 Encoding and Decoding</strong></p>
<p>Base64 (sextet-encoding) is the second of two encoding formats common to cryptography, including keyfiles exported by cryptographic libraries. In fact, PEM-encoding usually has the key encoded first with ASN.1 and then into base64. In base64 a stream of octets (8 bits per byte) is parsed as a bit string in groups of six bits (hence sextet) which is then mapped to one of 64 printable characters.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RECVBUF_LEN 1024</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">[</span><span class="n">RECVBUF_LEN</span><span class="p">];</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">recv_len</span><span class="p">;</span>

<span class="c1">// read incoming to `recv_buf` update `recv_len`</span>
<span class="n">network_recv</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_len</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">rsa_pubkey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">;</span>

<span class="c1">// ** Decode PEM Base64 encoding **</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">octet_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cryptx_base64_get_decoded_len</span><span class="p">(</span><span class="n">recv_len</span><span class="p">);</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">octet_data</span><span class="p">[</span><span class="n">octet_len</span><span class="p">];</span>
<span class="n">cryptx_base64_decode</span><span class="p">(</span><span class="n">octet_data</span><span class="p">,</span><span class="w"> </span><span class="n">recv_buf</span><span class="p">,</span><span class="w"> </span><span class="n">recv_len</span><span class="p">);</span>
<span class="c1">// If this is PEM, now you have a DER-encoded object.</span>
<span class="c1">// It&#39;s ASN.1 time, boi</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api/encoding.html#encoding"><span class="std std-ref">view Base64 documentation</span></a></p></li>
</ul>
</div>
<div class="section" id="hazardous-materials">
<h2>Hazardous Materials<a class="headerlink" href="#hazardous-materials" title="Permalink to this headline"></a></h2>
<p>Like many other cryptography libraries, CryptX consists of a main API layered over a collection  of primitives whose independent use may pose certain security risks, such as leaking information via side-channel attack or insecure cipher configuration. It is HIGHLY recommended that you stick to the main API but if you know what you are doing, you may enable the <strong>hazardous materials</strong> layer of the API like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CRYPTX_ENABLE_HAZMAT</span>
</pre></div>
</div>
<p>Once you do this in your code, you may call any of the hazmat functions just like the functions in the main API. To view what’s available in the hazardous layer, <span class="xref std std-ref">click here</span>.</p>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
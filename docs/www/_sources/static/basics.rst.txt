.. _basics:

Cryptography Basics
====================

This guide will define the CIA triad and help you to understand how to use Cryptx (and other cryptography libraries) as part of a secure infrastructure. We will define important terms and it is our hope that by reading this guide, you will have a basic understanding of how cryptography works and how and when to use various types of algorithms.

Information Security Policy
----------------------------

Information security can be expressed using a policy model referred to as the **CIA triad** which defines important elements of protecting a resource--confidentiality, integrity, and availability.

  - **Confidentiality** means that the data stored and exchanged by a resource should be confidential except to parties authorized to read it. Confidentiality is achieved through the encryption of information using a secure cipher under a key known only to authorized parties.
  
  - **Integrity** means that the data should not be modified either on disk or in transit except by parties authorized to modify said data. Integrity is achieved through the usage of a hash, signature, or authentication tag included with the data that needs integrity assurance.
  
  - **Availability** means that a resource should be resistant to attempts to disrupt its functionality. This includes resistance to such things as denial of service as well as possible data loss or compromise. This can be achieved through redunancy of systems or services, multiple backups, and intrusion detection software that can detect and react to DOS attacks.
  
Cryptographic libraries such as CryptX typically deal with the first two elements of this model, confidentiality and integrity. Service developers need to implement their own considerations for availablity.


Encryption
-----------

**Encryption** is a transformation of information, usually under some key, such that deciphering the output (referred to as *ciphertext*) without the key is extremely difficult. A pair of inverse algorithms, one for encryption and one for decryption under a given key, is referred to as a **cipher**. There are several types of encryption systems:

  - **Symmetric Encryption**: A pair of algorithms defined like so:
  
    .. code-block::
  
      Cipher(E, D, k):
        ciphertext = E(plaintext, k, j)
        plaintext = D(ciphertext, k, j)
  
    The defining property of symmetric encryption is that the same key is valid for both encryption and decryption. One such encryption system is the *Advanced Encryption Standard (AES)*. AES is currently regarded as the gold standard for symmetric encryption.
    
  - **Public Key Encryption**: A pair of algorithms defined like so:
  
    .. code-block::
  
      Cipher(E, D):
        pubkey,privkey = keygen()
        ciphertext = E(plaintext, k, pubkey)
        plaintext = D(ciphertext, k, privkey)
  
    The defining property of public key encryption is that there is a pair of keys, one public and one private. The setup of this system generally works like so: one endpoint generates a keypair, stores its private key to decrypt incoming messages, and distributes the public key in the clear so other parties can encrypt messages for it. One such encryption system is *Rivest-Shamir Adleman (RSA)*. In this system, the encrypt and decrypt algorithms are the same (a modular exponentation) and the keypair faciliates the encryption by having the public and private key be modular inverses of each other.
    
  - **Key Exchange Protocols**: A pair of algorithms defined like so:
  
    .. code-block::
  
      KEX:
        pubkey,privkey = keygen()
        K = gen_secret()
  
    Note that the definition is way more vague this time because key exchange works differently. Key Exchange is usually not a form of encryption but an algorithm that uses number relationships to arrive at the same key for different sets of numbers. One such system (implemented within CryptX) is *Elliptic Curve Diffie-Hellman (ECDH)*. ECDH operates like so:
    
    .. code-block::
    
      ECDH:
        Defines G as a base point of maximal order on a given elliptic curve
        Defines `gen_pubkey(privkey)` as an algorithm that computes `pubkey = privkey * G` over the elliptic curve.
        Defines `gen_secret(privkey, rpubkey)` as an algorithm that computes `secret = privkey * rpubkey * cofactor` over the elliptic curve.
        privkey = rand()
        pubkey = gen_pubkey(privkey)
        secret = gen_secret(privkey, rpubkey)
        
    ECDH faciliates agreement on a secret by having both parties run through the algorithm. First each party generates a pair of keys and exchanges public keys with the other party. Then the secret generation algorithm takes advantage of the relationship between opposing public/private keys over the given curve to arrive at the same secret at both endpoints.
    
    
  Key Negotiation and Secure Session Construction
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
  Having defined the three main forms of "encryption", we can now discuss how to create a secure session (like the ones faciliated by STARTTLS, SSL, and other secure protocols).
  
  The most common method of session negotiation is use RSA to handshake on a secret for symmetric encryption and to then use AES for the rest of the session. ECDH can be substituted for RSA if the library you are using supports it.
  

Randomness
-----------

Randomness is so integral to cryptography that it gets first mention in this guide. Why is it so important, you might ask. Ever talk in Pig Latin with your friends when you were younger? Assuming you were never told how it works, how difficult would you say it would be to ascertain how Pig Latin transforms words? If your answer is "not difficult", you'd be right. The next question is why is this? If your answer is "because every word is transformed in exactly the same way, so eventually you'd notice a pattern", you'd be correct. In the simplest context, encryption having a discernable pattern defeats said encryption as soon as that pattern can be guessed with confidence.

Randomization is the answer to this problem. Secure encryption systems require that the output of said encryption be indistinguishable from truly random output. They accomplish this by incorporating

<!DOCTYPE html>
<html>
	<head>
		<title>CryptX Documentation</title>
		<link type="text/css" rel="stylesheet" href="style.css" />
		<link rel="stylesheet" href="scripts/highlight/styles/default.min.css">
			<script src="scripts/highlight/highlight.min.js"></script>
		<style>
		</style>
	</head>
	<body>
		<div id="sidebar">
			<div id="title"><a href="index.html">
				CryptX
				<span style="font-size:50%;">11</span>
			</a></div><br />
			<div class="major-header">INTRODUCTION</div>
				<div class="navitem"><a href="index.html">What is CryptX?</a></div>
				<div class="navitem"><a href="installing.html">Installing the Libraries</a></div>
			<div class="major-header">COMPONENTS &amp; API</div>
				<div class="navitem"><a href="hashlib.html">HASHLIB</a></div>
				<div class="navitem"><a href="encrypt.html">ENCRYPT</a></div>
				<div class="navitem active">ENCODEX</div>
			<div class="major-header">MORE INFO</div>
				<div class="navitem"><a href="cryptanalysis.html">Cryptanalysis</a></div>
				<div class="navitem"><a href="credits.html">Credits</a></div>
				<div class="navitem"><a href="legal.html">Legal</a></div>
			
		</div>
		<div id="content"><div>
			<p><span style="font-weight:bold;">ENCODEX</span> provides support for encoding, decoding, and parsing to and from multiple encoding schemes.</p>
			<div class="major-header">Authors</div>
			<ul>
				<li>Anthony Cagliano</li>
				<li>Adam Beckingham</li>
			</ul>
			<div class="major-header">API Documentation</div>
			<p>This page will detail usage guidelines and requirements for the encoding API provided by the ENCODEX library within CryptX. If you plan to use it within your application, please take care to familiarize yourself with the API invocation, constraints, and best practices.</p>
			<div class="alert">
				This red tooltip style indicates security-critical information. It provides implementation details that, if ignored, may result in your application leaking information. If you have any questions or do not understand something please contact me for clarification. Do not ignore the tooltip.
			</div>
			<div class="more-info">
				This yellow tooltip style indicates a best practice or other information of note that is not necessarily security-critical but may cause unexpected behavior if not followed.
			</div><br />
			<div class="section">
				<div class="minor-header">Abstract Syntax Notation One Encoding (ASN.1)</div>
				<div class="section side-ruled">
					<p>ASN.1 is a data encoding format common to cryptography in which data is represented as a series of objects consisting of a tag, object size, and object data. The most commonly occurring serialization format for ASN.1 is <span style="font-weight:bold">DER</span>, which stands for <span style="font-style:italic;">Distinguished Encoding Rules</span>. The API is quite simple.</p>
					
					<pre class="code"><code class="language-c">uint8_t asn1_data = { /* some random ASN.1 data here */ };
						struct cryptx_asn1_context asn1_state;&emsp;&emsp;// stateful parser context
						asn1_error_t err;&emsp;&emsp;&emsp;&emsp;// track response codes from parser
						uint8_t *ptr;&emsp;&emsp;&emsp;&emsp;// pointer to data for each element
						size_t elem_len;&emsp;&emsp;&emsp;&emsp;// length of the element
						uint8_t tag;&emsp;&emsp;&emsp;&emsp;// tag value of the element
						uint8_t flags;&emsp;&emsp;&emsp;&emsp;// flags for the element
						// note that the above are reserved variables for the API to update
						
						// initialize the parser. Return if error.
						// NEVER ignore errors from things. It's how you crash stuff.
						err = cryptx_asn1_start(&asn1_state, asn1_demo, sizeof asn1_demo);
						if(err != ASN1_OK) return 1;
						
						// loop until END-OF-FILE returned
						while(err != ASN1_EOF){
						&emsp;&emsp;err = cryptx_asn1_decode(&asn1_state, &ptr, &elem_len, &tag, &flags);
						&emsp;&emsp;if(err) sprintf(CEMU_CONSOLE, "Decoder error %u\n", err);
						&emsp;&emsp;else
						&emsp;&emsp;&emsp;&emsp;printf("Object Data, Tag Id: %u, Flags: %u, Size: %u, Addr: %p\n",<br />
						&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;tag, flags, elem_len, ptr);
						&emsp;&emsp;if(!CRYPTX_ASN1_ISCONSTRUCTED(flags))
						&emsp;&emsp;&emsp;&emsp;// if the element is PRIMITIVE type, skip to avoid recursing into it
						&emsp;&emsp;&emsp;&emsp;err = cryptx_asn1_next(&asn1_state);
						}
					</code></pre>
					
					<p>Below, I will describe the PKCS#8 (PKCS standing for <span style="font-style:italic;">Public Key Cryptographic Standards</span>) ASN.1 serialization format. This is a format commonly utilized by cryptography libraries for exporting public and private keys. If you output using a different serialization format, you will need to look it up to see how to use the decoding API to extract the information you need.</p>
					<pre class="code"><code class="language-c">PKCS#8 encoding format for DER-encoded public keys
						PublicKeyInfo ::= SEQUENCE {
							&emsp;&emsp;algorithm       AlgorithmIdentifier :: SEQUENCE {
							&emsp;&emsp;&emsp;&emsp;algorithm_id&emsp;&emsp;&emsp;&emsp;OBJECT IDENTIFIER,
							&emsp;&emsp;&emsp;&emsp;parameters&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ANY DEFINED BY algorithm OPTIONAL
							&emsp;&emsp;}
							&emsp;&emsp;PublicKey       BIT STRING
						}
						
						
						// Output of the CryptX ASN.1 API using the `asn1_demo` example
						----------------------------------
						ENCODEX ASN.1 Decoder Demo
						
						ASN.1 parser init complete. Exit code 0.
						// PublicKeyInfo encapsulating SEQUENCE algorithm (CONSTRUCTED)
						Object Data, Tag Id: 16, Flags: 1, Size: 159, Addr: d1ab80
						// algorithm encapsulating algorithm_id, parameters (CONSTRUCTED)
						Object Data, Tag Id: 16, Flags: 1, Size: 13, Addr: d1ab82
						// algorithm_id (PRIMITIVE)
						Object Data, Tag Id: 6, Flags: 0, Size: 9, Addr: d1ab84
						// parameters (NULL FIELD) (PRIMITIVE)
						Object Data, Tag Id: 5, Flags: 0, Size: 0, Addr: d1ab8f
						// Public Key (PRIMITIVE)
						Object Data, Tag Id: 3, Flags: 0, Size: 141, Addr: d1ab92
						>>EOF
						</code></pre>
					
					<dl>
						<dt class="lib-ref">ASN.1 API Overview<hr />
							&emsp;Response Codes
							<table width="100%" style="margin-left:5%; font-size:12px;">
								<col width="40%" />
								<col width="60%" />
								<tr><td>ASN1_OK</td><td>No error occurred</td></tr>
								<tr><td>ASN1_EOF</td><td>End of data stream reached</td></tr>
								<tr><td>AES_INVALID_ARG</td><td>One or more arguments invalid</td></tr>
								<tr><td>ASN1_LEN_OVERFLOW</td><td>Element too long for architecture.<br />The parser will be unable to proceed.</td></tr>
							</table>
						</dt>
						<dd></dd><br />
						<dt class="lib-ref">asn1_error_t cryptx_asn1_start(struct cryptx_asn1_context *context, void *asn1_data, size_t len);</dt>
						<dd>Initializes a stateful ASN.1 parser context.<br />
							<span class="param">context</span>: Pointer to ASN.1 context.<br />
							<span class="param">asn1_data</span>: Pointer to ASN.1-encoded data stream.<br />
							<span class="param">len</span>: Length of data stream.<br />
							<span class="param">returns</span>: [asn1_error_t] Status code returned by the parser initialization.
						</dd><br />
						<dt class="lib-ref">asn1_error_t cryptx_asn1_decode(<br />
							&emsp;&emsp;&emsp;&emsp;struct cryptx_asn1_context *context,<br />
							&emsp;&emsp;&emsp;&emsp;uint8_t **element_data, size_t *element_len,<br />
							&emsp;&emsp;&emsp;&emsp;uint8_t *tag, uint8_t *flags);</dt>
						<dd>Parses the data at the current operating offset for more elements, returning the next element found.<br />
							<span class="param">context</span>: Pointer to ASN.1 context.<br />
							<span class="param">element_data</span>: Pointer to address of data segment of next element found.<br />
							<span class="param">element_len</span>: Pointer to length of next element found.<br />
							<span class="param">tag</span>: Pointer to tag value of next element found, with high 3 bits stripped.<br />
							<span class="param">flags</span>: Pointer to flags stripped from tag.<br />
							<span class="param">returns</span>: [asn1_error_t] Status code returned by the parser initialization.
							<div class="more-info">
								element_data, element_len, tag, and flags are all modified by this function to reflect the metadata of the next element. If you need their values for later, save them before calling this function again.
							</div>
							<div class="more-info">
								element_data is a pointer to the element data segment within the original block of ASN.1-encoded data. If you need that data, you can use <span style="font-family:monospace;">memcpy(dest, *element_data, element_len);</span> to read it elsewhere, or just access it in place. This will depend on what you do with the original data buffer after decoding.
							</div>
							<div class="alert">
								Calling this function on an element with no elements inside it (PRIMITIVE) can result in undefined behavior from returning ASN1_LEN_OVERFLOW or ASN1_EOF to just returning an invalid object. <span class="font-weight:bold;">If the element is of type PRIMITIVE, call cryptx_asn1_next() before the next call to this function.</span><br /><br />
								<span style="font-weight:bold;">There is one exception to this. The PublicKey element within the PKCS&num;8 standardization is actually a PKCS&num;1 PublicKey structure with a zero byte prepended and then encoded as a primitive BIT STRING.</span> In this particular case, it is safe to call this function on that element to recurse into the PublicKey structure and extract the public modulus and exponent of your key.
							</div>
						</dd><br />
						<dt class="lib-ref">asn1_error_t cryptx_asn1_next(struct cryptx_asn1_context *context);</dt>
						<dd>Advances the current operating offset to move to the next element of the same parser level.<br />
							<span class="param">context</span>: Pointer to ASN.1 context.<br />
							<span class="param">returns</span>: [asn1_error_t] Status code returned by the parser initialization.
						</dd>
					</dl>
				</div><br />
				<div class="minor-header">Base 64 Encoding</div>
				<div class="section side-ruled">
					<p>A data encoding format also common to cryptography in which data is expressed in six (6) bit groups of data (sextets) which are then mapped to one of 64 plaintext characters (A-Z,a-z,+/) and padding = characters. Base 64 is the encoding format used by PEM keyfiles.</p>
					<dl>
						<dt class="lib-ref">size_t cryptx_base64_encode(void* dest, const void* src, size_t len);</dt>
						<dd>Encodes a byte-encoded data stream into a sextet-encoded (base64) data stream.<br />
							<span class="param">dest</span>: Pointer to buffer to write output base64 data.<br />
							<span class="param">src</span>: Pointer to data to encode.<br />
							<span class="param">len</span>: Length of input data to encode.<br />
							<span class="param">returns</span>: [size_t] Length of output base64 data.
						</dd><br />
						<dt class="lib-ref">size_t cryptx_base64_decode(void* dest, const void* src, size_t len);</dt>
						<dd>Decodes a sextet-encoded data stream into a byte-encoded data stream.<br />
							<span class="param">dest</span>: Pointer to buffer to write output data.<br />
							<span class="param">src</span>: Pointer to sextet data to decode.<br />
							<span class="param">len</span>: Length of input data to decode.<br />
							<span class="param">returns</span>: [size_t] Length of output data.
						</dd>
					</dl>
					
					
				</div><br />
				<div class="minor-header">Bits-Per-Pixel Encoding (BPP)</div>
				<div class="section side-ruled">
					<p>A form of encoding/compression in which multiple bytes of data are collapsed into a smaller form based on the bit-length of the value&apos;s upper bound. For example, 8 bytes of values 0-3 (a 2-bit value) could be compressed into 4-bpp encoding and require only 2 bytes to represent. In the same way, 8 bytes of values 0-1 (a 1-bit value) could be compressed into 1-bpp encoding and require only 1 byte to represent.</p>
					<dl>
						<dt class="lib-ref">bool cryptx_bpp_encode(void* dest, const void* src, size_t len, uint8_t bpp);</dt>
						<dd>Encodes a byte-encoded data stream into bit-per-pixel encoding.<br />
							<span class="param">dest</span>: Pointer to buffer to write bpp-encoded data to.<br />
							<span class="param">src</span>: Pointer to data to encode/compress.<br />
							<span class="param">len</span>: Length of the encoded (output) data stream.<br />
							<span class="param">bpp</span>: Number of bits-per-pixel to encode into.<br />
						</dd><br />
						<dt class="lib-ref">bool cryptx_bpp_decode(void* dest, const void* src, size_t len, uint8_t bpp);</dt>
						<dd>Decodes a bit-per-pixel-encoded data stream into a byte-encoded data stream.<br />
							<span class="param">dest</span>: Pointer to buffer to write decoded data to.<br />
							<span class="param">src</span>: Pointer to data to decode/decompress.<br />
							<span class="param">len</span>: Length of the encoded (input) data stream.<br />
							<span class="param">bpp</span>: Number of bits-per-pixel to decode from.<br />
						</dd>
						
					</dl>
					<div class="more-info">
						This encoding method truncates if the bitwise compression is not large enough to hold the value within the BPP encoding. For example, if you have a 4-bit value and you convert to 2-bpp encoding, the higher two bits of the data value will be lost. Please account for this properly within applications that make use of this module.
					</div>
				</div>
			</div><br />
			<hr />
			<iframe src="scripts/rtd-msg.html" style="width:100%; height:50px; border:none;"></iframe>
			<br />
		</div></div>
	</body>
	<script>hljs.highlightAll();</script>
</html>
